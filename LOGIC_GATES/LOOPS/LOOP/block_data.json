{
  "description": null,
  "parameters": [
    {
      "name": "num_loops",
      "type": "int",
      "description": "number of times to iterate through body nodes, default is \"-1\" meaning infinity."
    }
  ],
  "returns": [],
  "code": "import json\nfrom typing import TypedDict, Any, Optional\nfrom flojoy import JobResultBuilder, DataContainer, flojoy, DefaultParams, SmallMemory\n\nmemory_key = \"loop-info\"\n\n\nclass LoopOutput(TypedDict):\n    body: Any\n    end: Any\n\n\nclass LoopData:\n    def __init__(\n        self,\n        node_id: str,\n        num_loops: int = -1,\n        current_iteration: int = 0,\n        is_finished: bool = False,\n    ) -> None:\n        self.node_id = node_id\n        self.num_loops = int(num_loops)\n        self.current_iteration = int(current_iteration)\n        self.is_finished = bool(is_finished)\n\n    def restart(self):\n        self.current_iteration = 0\n        self.is_finished = False\n\n    def step(self):\n        self.current_iteration += 1\n        if self.current_iteration > self.num_loops:\n            self.is_finished = True\n\n    def get_data(self):\n        return {\n            \"node_id\": self.node_id,\n            \"num_loops\": self.num_loops,\n            \"current_iteration\": self.current_iteration,\n            \"is_finished\": self.is_finished,\n        }\n\n    @staticmethod\n    def from_data(node_id: str, data: dict[str, Any]):\n        loop_data = LoopData(\n            node_id,\n            num_loops=data.get(\"num_loops\", -1),\n            current_iteration=data.get(\"current_iteration\", 0),\n            is_finished=data.get(\"is_finished\", False),\n        )\n        return loop_data\n\n    def print(self, prefix: str = \"\"):\n        print(f\"{prefix}loop Data:\", json.dumps(self.get_data(), indent=2))\n\n\n@flojoy(inject_node_metadata=True)\ndef LOOP(\n    default_params: DefaultParams,\n    default: Optional[DataContainer] = None,\n    num_loops: int = -1,\n) -> LoopOutput:\n    \"\"\"The LOOP node is a specialized node that iterates through the body nodes for a given number of times.\n\n    Parameters\n    ----------\n    num_loops : int\n        number of times to iterate through body nodes, default is \"-1\" meaning infinity.\n    \"\"\"\n\n    node_id = default_params.node_id\n\n    loop_data: LoopData = load_loop_data(node_id, num_loops)\n\n    # given the addition of the break node, it is possible that\n    # another node can write to the data of this loop. we have to\n    # now check if that's the case, and if so, return\n    if loop_data.get_data().get(\"is_finished\"):\n        # ensure that the node can be restarted after\n        # breaking, like in a nested loop\n        loop_data.is_finished = False\n        store_loop_data(node_id, loop_data)\n        return build_result([default] if default else [], True)\n\n    # again owing to the addition of the break node, we\n    # need to write the data to memory first before\n    # processing logic so other nodes can always see the data\n    store_loop_data(node_id, loop_data)\n\n    # infinite loop\n    if num_loops == -1:\n        return build_result(inputs=[default] if default else [], is_loop_finished=False)\n\n    # loop was previously finished, but now re-executing, so restart\n    if loop_data.is_finished:\n        loop_data.restart()\n    else:\n        loop_data.step()\n\n    if not loop_data.is_finished:\n        store_loop_data(node_id, loop_data)\n    else:\n        delete_loop_data(node_id)\n\n    return build_result([default] if default else [], loop_data.is_finished)\n\n\ndef load_loop_data(node_id: str, default_num_loops: int) -> LoopData:\n    data: dict[str, Any] = SmallMemory().read_memory(node_id, memory_key) or {}\n    loop_data = LoopData.from_data(\n        node_id=node_id, data={\"num_loops\": default_num_loops, **data}\n    )\n    return loop_data\n\n\ndef store_loop_data(node_id: str, loop_data: LoopData):\n    SmallMemory().write_to_memory(node_id, memory_key, loop_data.get_data())\n\n\ndef delete_loop_data(node_id: str):\n    SmallMemory().delete_object(node_id, memory_key)\n\n\ndef build_result(inputs: list[DataContainer], is_loop_finished: bool):\n    return LoopOutput(\n        body=JobResultBuilder()\n        .from_inputs(inputs)\n        .flow_by_flag(\n            flag=is_loop_finished, false_direction=[\"body\"], true_direction=[\"end\"]\n        )\n        .build(),\n        end=JobResultBuilder()\n        .from_inputs(inputs)\n        .flow_by_flag(\n            flag=is_loop_finished, false_direction=[\"body\"], true_direction=[\"end\"]\n        )\n        .build(),\n    )\n"
}