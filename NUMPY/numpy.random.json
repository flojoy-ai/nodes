{
    "SeedSequence": "\n    return DataContainer(x=dc[0].y, y=seed_sequence)",
    "RandomState": "\n\ndef RANDOMSTATE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Create a random number generator.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance with x=dc[0].y, y=random number generator.\n    \n    \"\"\"\n    seed: int = params.get('seed', None)\n    state: np.random.RandomState = np.random.RandomState(seed=seed)\n    return DataContainer(x=dc[0].y, y=state.RandomState(dc[0].y))",
    "BitGenerator": "\n\ndef BITGENERATOR(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Create a new DataContainer.\n    \n    Parameters\n    ----------\n    dc : list\n        List of numpy.random.Generator objects.\n    params : dict\n        Dictionary of optional parameters.\n    \n    Returns\n    -------\n    out : DataContainer\n        A new DataContainer object.\n    \n    Examples\n    --------\n    >>> dc = BITGENERATOR(dc[0].y, {'a': 1, 'b': 2})\n    >>> dc\n    <DataContainer object at 0x7f9f9f9f9f9f>\n    \"\"\"\n    a: int = params.get('a', None)\n    b: int = params.get('b', None)\n    out = np.random.BitGenerator(dc[0].y, a=a, b=b)\n    return DataContainer(x=dc[0].y, y=out)",
    "MT19937": "\n    \n    # Return the custom class\n    return DataContainer(x=dc[0].y, y=rng)",
    "SFC64": "\n\ndef SFC64(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a 64-bit Split-Fetch-Combine random number generator.\n    \n    Parameters\n    ----------\n    dc : list\n        List of two 64-bit integers.\n    params : dict\n        Optional parameters.\n        - a : int\n            The multiplier. Must be an odd integer. Default is 5489.\n        - c : int\n            The increment. Must be an odd integer. Default is 29943829.\n        - x : int\n            The initial state. Must be an integer. Default is 0.\n    \n    Returns\n    -------\n    DataContainer\n        An instance of the DataContainer class, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    \"\"\"\n    # Strictly type all internal variables\n    a: int = params.get('a', 5489)\n    c: int = params.get('c', 29943829)\n    x: int = params.get('x', 0)\n    \n    # Return the result of the function\n    out = numpy.random.SFC64(dc[0].y, a=a, c=c, x=x)\n    return DataContainer(x=dc[0].y, y=out)",
    "Generator": "\n\ndef GENERATOR(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Create a new Generator object and seed it with data from dc[0].y.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of optional parameters.\n    \n    Returns\n    -------\n    DataContainer\n        A new DataContainer object, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Original Docstring\n    ------------------\n    Create a new Generator object and seed it with data from `seed`.\n    \n    Parameters\n    ----------\n    seed : int or array_like, optional\n        Seed for `RandomState`.\n        Must be convertible to 32 bit unsigned integers.\n    \n    Returns\n    -------\n    Generator\n        A new Generator object.\n    \"\"\"\n    seed = params.get('seed', dc[0].y)\n    out = np.random.Generator(seed)\n    return DataContainer(x=dc[0].y, y=out)",
    "PCG64DXSM": "\n\ndef PCG64DXSM(dc: List[float], params: Dict[str, Any]) -> DataContainer:\n    \"\"\"\n    numpy.random.PCG64DXSM\n    ------------------------\n    PCG64DXSM is a 64-bit variant of the PCG family of random number generators\n    using the XSH RS scheme.\n\n    Parameters\n    ----------\n    dc : List[float]\n        The primary argument of the function.\n    params : Dict[str, Any]\n        Optional arguments taken as keys of the same name from the dictionary.\n\n    Returns\n    -------\n    DataContainer\n        An instance of the DataContainer class, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.random.PCG64DXSM(dc[0].y, a=1, b=2, c=3)\n    DataContainer(x=dc[0].y, y=0.123456789)\n    \"\"\"\n    # Strictly type all internal variables\n    a: int = params.get('a', 0)\n    b: int = params.get('b', 0)\n    c: int = params.get('c', 0)\n\n    # Return the DataContainer instance\n    return DataContainer(x=dc[0].y, y=np.random.PCG64DXSM(dc[0].y, a=a, b=b, c=c))",
    "bytes": "\n\ndef BYTES(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Return random bytes.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    DataContainer\n        DataContainer instance with x=dc[0].y, y=random bytes.\n    \n    Examples\n    --------\n    >>> BYTES([dc[0].y], {'length': 10})\n    DataContainer(x=dc[0].y, y=b'\\x9f\\x03\\xdc\\x9e\\xad\\x18\\xda\\x06\\x97\\x96')\n    \"\"\"\n    length: int = params.get('length', 1)\n    return DataContainer(x=dc[0].y, y=np.random.bytes(length))",
    "binomial": "\n\ndef BINOMIAL(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a binomial distribution.\n    \n    Samples are drawn from a binomial distribution with specified\n    parameters, n trials and p probability of success where\n    n an integer >= 0 and p is in the interval [0,1]. (n may be\n    input as a float, but it is truncated to an integer in use)\n    \n    Parameters\n    ----------\n    dc[0].y : int or array_like of ints\n        Parameter of the distribution, >= 0. Floats are also accepted,\n        but they will be truncated to integers.\n    params['n'] : int or array_like of ints, optional\n        Number of trials, >= 0.  Floats are also accepted, but they\n        will be truncated to integers.\n    params['p'] : float or array_like of floats, optional\n        Probability of success in each trial.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    n: int = params.get('n', 1)\n    p: float = params.get('p', 0.5)\n    out = np.random.binomial(dc[0].y, n, p)\n    return DataContainer(x=dc[0].y, y=out)",
    "Philox": "\n\ndef PHILOX(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Generate random numbers using the Philox algorithm.\n    \n    Parameters\n    ----------\n    dc : list\n        List of two integers, the first of which is the number of\n        dimensions and the second is the number of random numbers\n        to generate.\n    params : dict\n        Dictionary of optional parameters.\n    \n    Returns\n    -------\n    out : DataContainer\n        Instance of the DataContainer class, instantiated with the\n        arguments x=dc[0].y, y=<out>, where <out> is the array of\n        shape (dc[0], dc[1]) containing random numbers generated\n        using the Philox algorithm.\n    \n    Other Parameters\n    ----------------\n    key : int, optional\n        Key used to generate the random numbers. Must be an\n        integer of length 4. Default is None.\n    rounds : int, optional\n        Number of rounds used in the Philox algorithm. Must be\n        an integer. Default is 10.\n    a : int, optional\n        Parameter used in the Philox algorithm. Must be an\n        integer. Default is 0x9E3779B97F4A7C15.\n    b : int, optional\n        Parameter used in the Philox algorithm. Must be an\n        integer. Default is 0xBB67AE8584CAA73B.\n    \"\"\"\n    # Strictly type all internal variables\n    key: int = params.get('key', None)\n    rounds: int = params.get('rounds', 10)\n    a: int = params.get('a', 0x9E3779B97F4A7C15)\n    b: int = params.get('b', 0xBB67AE8584CAA73B)\n    \n    # Generate random numbers using the Philox algorithm\n    out = np.random.Philox(dc[0], dc[1], key=key, rounds=rounds, a=a, b=b)\n    \n    return DataContainer(x=dc[0].y, y=out)",
    "PCG64": "\n\ndef PCG64(dc: List[Dict[str, Any]], params: Dict[str, Any]) -> DataContainer:\n    \"\"\"\n    PCG64(dc[0].y, *, size=None, dtype=None, out=None)\n    \n    Draw samples from a PCG64 random number generator.\n    \n    Parameters\n    ----------\n    dc[0].y : int\n        Seed for the random number generator.\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    dtype : dtype, optional\n        Desired dtype of the result. All dtypes are determined by their\n        name, i.e., 'int64', 'float64', 'complex128', etc.\n        Default is None, in which case the dtype of `dc[0].y` is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape and buffer length as the expected output, but the\n        type (of the output) will be cast if necessary.\n\n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    size: Optional[Union[int, Tuple[int, ...]]] = params.get('size', None)\n    dtype: Optional[np.dtype] = params.get('dtype', None)\n    out: Optional[np.ndarray] = params.get('out', None)\n    return DataContainer(x=dc[0].y, y=np.random.PCG64(dc[0].y, size=size, dtype=dtype, out=out))",
    "beta": "\n\ndef BETA(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Beta distribution.\n    \n    The Beta distribution is a special case of the Dirichlet distribution,\n    and is related to the Gamma distribution.  It has the probability\n    distribution function\n    \n    .. math:: f(x; a,b) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1}\n                                                (1 - x)^{\\beta - 1},\n    \n    where the normalisation, B, is the beta function,\n    \n    .. math:: B(\\alpha, \\beta) = \\int_0^1 t^{\\alpha - 1}\n                                            (1 - t)^{\\beta - 1} dt.\n    \n    It is often seen in Bayesian inference and order statistics.\n    \n    Parameters\n    ----------\n    a : float or array_like of floats\n        Alpha, positive (>0).\n    b : float or array_like of floats\n        Beta, positive (>0).\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Raises\n    ------\n    ValueError\n        If any of the parameters are outside their supported range.\n    \n    Examples\n    --------\n    Draw samples from the distribution:\n    \n    >>> a, b = 2.5, 1.5  # shape parameters\n    >>> s = np.random.beta(a, b, 1000)\n    \n    Display the histogram of the samples, along with\n    the probability density function:\n    \n    >>> import matplotlib.pyplot as plt\n    >>> count, bins, ignored = plt.hist(s, 30, density=True)\n    >>> x = np.linspace(0, 1, 100)\n    >>> y = a*x**(a-1) * (1-x)**(b-1)\n    >>> plt.plot(x, y, linewidth=2, color='r')\n    >>> plt.show()\n    \n    \"\"\"\n    a: float = params.get('a', None)\n    b: float = params.get('b', None)\n    size: int = params.get('size', None)\n    \n    out = np.random.beta(a, b, size=size, **dc[0].y)\n    return DataContainer(x=dc[0].y, y=out)",
    "chisquare": "\n\ndef CHISQUARE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a chi-square distribution.\n    \n    The chi-square distribution is a special case of the gamma distribution\n    and is used in the common chi-square test for goodness of fit of an\n    observed distribution to a theoretical one.\n    \n    Parameters\n    ----------\n    df : float or array_like of floats\n        Degrees of freedom, should be > 0.\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    df: float = params.get('df', None)\n    size: tuple = params.get('size', None)\n    out = np.random.chisquare(dc[0].y, df=df, size=size)\n    return DataContainer(x=dc[0].y, y=out)",
    "default_rng": "\n\ndef DEFAULT_RNG(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Get a random number generator with a default BitGenerator.\n\n    Parameters\n    ----------\n    dc : list\n        List of objects to be used as the default BitGenerator.\n    params : dict\n        Optional parameters to be used in the function.\n\n    Returns\n    -------\n    out : DataContainer\n        A DataContainer instance with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n\n    \"\"\"\n    # Enforce strict typing\n    dc: list = dc\n    params: dict = params\n\n    # Get the primary argument\n    y: int = dc[0].y\n\n    # Get all optional arguments\n    seed: int = params.get('seed', None)\n    state: np.random.Generator = params.get('state', None)\n    bit_generator: np.random.BitGenerator = params.get('bit_generator', None)\n\n    # Call the function\n    out: np.random.default_rng = np.random.default_rng(y, seed=seed, state=state, bit_generator=bit_generator)\n\n    return DataContainer(x=dc[0].y, y=out)",
    "exponential": "\n\ndef EXPONENTIAL(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from an exponential distribution.\n    \n    Its probability density function is\n    \n    .. math:: f(x; \\\\frac{1}{\\\\beta}) = \\\\frac{1}{\\\\beta} \\exp(-\\\\frac{x}{\\\\beta}),\n    \n    for ``x > 0`` and 0 elsewhere. :math:`\\\\beta` is the scale parameter,\n    which is the inverse of the rate parameter :math:`\\\\lambda = 1/\\\\beta`.\n    The rate parameter is an alternative, widely used parameterization\n    of the exponential distribution [3]_.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data points.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    DataContainer\n        Instantiated DataContainer with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    \"\"\"\n    # Strictly type all internal variables\n    x: float = dc[0].y\n    beta: float = params.get('beta', 1.0)\n    \n    # Calculate and return the exponential distribution\n    out = (1.0 / beta) * np.exp(-x / beta)\n    return DataContainer(x=dc[0].y, y=out)",
    "choice": "\n\ndef CHOICE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Generate a random sample from a given 1-D array.\n    \n    Parameters\n    ----------\n    dc : list\n        List of 1-D arrays from which to choose.\n    params : dict\n        Optional keyword arguments.\n        size : int or tuple of ints, optional\n            Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned.\n    replace : boolean, optional\n        Whether the sample is with or without replacement\n    p : 1-D array_like, optional\n        The probabilities associated with each entry in `a`.\n        If not given the sample assumes a uniform distribution over all\n        entries in `a`.\n\n    Returns\n    -------\n    samples : DataContainer\n        The generated random samples, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function\n\n    Raises\n    ------\n    ValueError\n        If `a` and `p` have different lengths, or if any value in `p` is\n        negative or greater than 1.\n    \"\"\"\n    # Enforce strict typing\n    size: Optional[Union[int, Tuple[int, ...]]] = params.get('size', None)\n    replace: bool = params.get('replace', False)\n    p: Optional[np.ndarray] = params.get('p', None)\n    \n    # Call numpy.random.choice\n    out = np.random.choice(dc[0].y, size=size, replace=replace, p=p)\n    return DataContainer(x=dc[0].y, y=out)",
    "gamma": "\n\ndef GAMMA(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Gamma distribution.\n    \n    Samples are drawn from a Gamma distribution with specified parameters,\n    shape (sometimes designated \"k\") and scale (sometimes designated\n    \"theta\"), where both parameters are > 0.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    DataContainer\n        Instance of DataContainer with x=dc[0].y, y=drawn samples from the parameterized Gamma distribution.\n    \"\"\"\n    shape = params.get('shape', 1.0)\n    scale = params.get('scale', 1.0)\n    return DataContainer(x=dc[0].y, y=np.random.gamma(dc[0].y, shape, scale))",
    "get_state": "\n\ndef GET_STATE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Get the internal state of the random number generator.\n\n    Parameters\n    ----------\n    dc : list\n        List of random number generator objects.\n    params : dict\n        Dictionary of optional parameters.\n\n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance with x=dc[0].y, y=<out>, where <out> is the return value of the function.\n\n    \"\"\"\n    # Strictly type all internal variables\n    state: tuple = numpy.random.get_state(dc[0].y)\n\n    # Take all optional arguments as keys of the same name from the dictionary 'params'\n    for key, value in params.items():\n        state = numpy.random.get_state(dc[0].y, **{key: value})\n\n    return DataContainer(x=dc[0].y, y=state)",
    "gumbel": "\n\ndef GUMBEL(dc: list, params: dict) -> DataContainer:\n    \"\"\"Draw samples from a Gumbel distribution.\n    \n    Draw samples from a Gumbel distribution with specified location and scale.\n    The Gumbel distribution is a type of extreme value distribution. It may be\n    used to model the maximum value of a collection of samples of various\n    distributions.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data points.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    DataContainer\n        Instance of DataContainer with x=dc[0].y, y=samples from a Gumbel distribution.\n    \n    \"\"\"\n    loc: float = params.get('loc', 0.0)\n    scale: float = params.get('scale', 1.0)\n    size: int = params.get('size', None)\n    return DataContainer(x=dc[0].y, y=np.random.gumbel(loc=loc, scale=scale, size=size, x=dc[0].y))",
    "dirichlet": "\n\ndef DIRICHLET(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from the Dirichlet distribution.\n    \n    Draw `dc[0].y` samples from a Dirichlet distribution. The Dirichlet\n    distribution is a multivariate generalization of the beta distribution.\n    It is a distribution over probability vectors, i.e. vectors that sum to\n    1.\n    \n    Parameters\n    ----------\n    dc : list\n        List of length 1 containing the number of samples to draw.\n    params : dict\n        Dictionary containing the optional parameters of the function.\n        Keys must be:\n        - alpha : 1-D array-like, optional\n            Parameter of the distribution (1-D array-like).\n        - size : int or tuple of ints, optional\n            Output shape. If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn. Default is None, in which case a\n            single value is returned.\n    \n    Returns\n    -------\n    samples : DataContainer\n        The drawn samples, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    alpha: np.ndarray = params.get('alpha', None)\n    size: Union[int, Tuple[int, ...]] = params.get('size', None)\n    out = np.random.dirichlet(alpha, size=size, shape=dc[0].y)\n    return DataContainer(x=dc[0].y, y=out)",
    "geometric": "\n\ndef GEOMETRIC(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draws samples from the geometric distribution.\n    The geometric distribution is a discrete probability distribution of the number\n    of Bernoulli trials needed to get one success.\n    Parameters\n    ----------\n    p : float or array_like of floats\n        Probability of success in each trial. Must be in the range [0, 1].\n    size : int or tuple of ints, optional\n        Output shape. If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn. Default is None, in which case a\n        single value is returned.\n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    p = params.get('p', 0.5)\n    size = params.get('size', None)\n    return DataContainer(x=dc[0].y, y=np.random.geometric(p, size=size, dc[0].y))",
    "f": "\n\ndef F(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from an F distribution.\n    \n    Samples are drawn from an F distribution with specified parameters,\n    ndarrays of the same shape as `dc[0].y` are filled with the samples.\n    \n    Parameters\n    ----------\n    dc : list\n        List of ndarrays.\n    params : dict\n        Dictionary of parameters.\n        Must contain the following keys:\n        - 'dfn' : int or array_like of ints\n            Degrees of freedom in the numerator.\n        - 'dfd' : int or array_like of ints\n            Degrees of freedom in the denominator.\n        - 'size' : int or tuple of ints, optional\n            Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    dfn = params.get('dfn', None)\n    dfd = params.get('dfd', None)\n    size = params.get('size', None)\n    if dfn is None or dfd is None:\n        raise ValueError('dfn and dfd must be specified in params.')\n    if not isinstance(dfn, (int, np.integer)) or not isinstance(dfd, (int, np.integer)):\n        raise TypeError('dfn and dfd must be integers.')\n    out = np.random.f(dfn, dfd, size=size, out=dc[0].y)\n    return DataContainer(x=dc[0].y, y=out)",
    "lognormal": "\n\ndef LOGNORMAL(dc: list, params: dict) -> DataContainer:\n    \"\"\"Draw samples from a log-normal distribution.\n    \n    Samples are drawn from a log-normal distribution with specified mean,\n    standard deviation, and array shape. \n    \n    Parameters\n    ----------\n    dc : list\n        List of length 1 containing the mean of the log-normal distribution.\n    params : dict\n        Dictionary containing the standard deviation (key: 's') and the shape\n        (key: 'shape') of the log-normal distribution.\n    \n    Returns\n    -------\n    samples : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    mean: float = dc[0].y\n    s: float = params['s']\n    shape: tuple = params['shape']\n    samples: float = np.random.lognormal(mean, s, shape)\n    return DataContainer(x=dc[0].y, y=samples)",
    "logistic": "\n\ndef LOGISTIC(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a logistic distribution.\n    \n    Samples are drawn from a logistic distribution with specified mean and\n    standard deviation.\n    \n    Parameters\n    ----------\n    dc[0].y : float or array_like of floats\n        Mean of the distribution.\n    loc : float or array_like of floats, optional\n        Location parameter. Default is 0.\n    scale : float or array_like of floats, optional\n        Scale parameter. Default is 1.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    loc = params.get('loc', 0)\n    scale = params.get('scale', 1)\n    out = np.random.logistic(dc[0].y, loc, scale)\n    return DataContainer(x=dc[0].y, y=out)",
    "laplace": "\n\ndef LAPLACE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Laplace distribution.\n    \n    The Laplace distribution is similar to the Gaussian/normal distribution, but is sharper at the peak and has fatter tails. It represents the difference between two independent, identically distributed exponential random variables.\n    \n    Parameters\n    ----------\n    dc : list\n        List of length 1 containing the mean of the distribution.\n    params : dict\n        Dictionary containing optional parameters.\n        - loc : float or array_like of floats, optional\n            The position, μ, of the distribution peak. Default is 0.\n        - scale : float or array_like of floats, optional\n            The exponential decay, λ, of the distribution. Default is 1.\n        - size : int or tuple of ints, optional\n            Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None.\n        - random_state : int or np.random.RandomState, optional\n            RandomState instance or seed used for drawing random variates.\n            If None (or np.random), the global np.random state is used.\n            Default is None.\n    \n    Returns\n    -------\n    samples : DataContainer\n        The samples from the Laplace distribution, instantiated as a DataContainer with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    loc = params.get('loc', 0)\n    scale = params.get('scale', 1)\n    size = params.get('size', None)\n    random_state = params.get('random_state', None)\n    \n    out = np.random.laplace(dc[0].y, loc=loc, scale=scale, size=size, random_state=random_state)\n    return DataContainer(x=dc[0].y, y=out)",
    "hypergeometric": "\n\ndef HYPERGEOMETRIC(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Hypergeometric distribution.\n    \n    Samples are drawn from a Hypergeometric distribution with specified\n    parameters, ngood (ways to make a good selection), nbad (ways to make\n    a bad selection), and nsample = number of items sampled, which is less\n    than or equal to the sum ngood + nbad.  'ngood' and 'nbad' can be\n    thought of as representing the number of white and black balls in an\n    urn, respectively.\n    \n    Parameters\n    ----------\n    dc : list\n        List of two elements, the first element must be a float representing\n        the number of good items, and the second element must be a float\n        representing the number of bad items.\n    params : dict\n        Dictionary of optional parameters.  Allowed keys are:\n        * size : int or tuple of ints, optional\n            Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned.\n        * replace : boolean, optional\n            Whether the sample is with or without replacement\n        * p : 1-D array_like, optional\n            The probabilities associated with each entry in a.\n            If not given the sample assumes a uniform distribution over all\n            entries in a.\n    \n    Returns\n    -------\n    samples : DataContainer\n        The returned samples, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Raises\n    ------\n    ValueError\n        If dc[0] or dc[1] is negative, or if dc[0] + dc[1] < nsample.\n    \"\"\"\n    # Strictly type all internal variables\n    ngood: float = dc[0]\n    nbad: float = dc[1]\n    size: int = params.get('size', None)\n    replace: bool = params.get('replace', False)\n    p: list = params.get('p', None)\n    \n    # Return the result of the function\n    out = np.random.hypergeometric(ngood, nbad, size, replace, p)\n    return DataContainer(x=dc[0].y, y=out)",
    "multinomial": "\n\ndef MULTINOMIAL(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a multinomial distribution.\n    \n    The multinomial distribution is a multivariate generalization of the binomial\n    distribution. Take an n-dimensional vector `p` of probabilities, and sample\n    `n` independent times from each of the `n` categories. The multinomial\n    distribution describes the probability of counts among the categories.\n    \n    Parameters\n    ----------\n    dc : list\n        List of numpy arrays containing the probabilities of each category.\n    params : dict\n        Optional keyword arguments.\n        n : int or array_like of ints\n            Number of samples to draw for each row.\n        size : int or tuple of ints, optional\n            Output shape. If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn. Default is None, in which case a\n            single value is returned.\n    Returns\n    -------\n    out : DataContainer\n        The drawn samples, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    n = params.get('n', 1)\n    size = params.get('size', None)\n    out = np.random.multinomial(dc[0].y, n=n, size=size)\n    return DataContainer(x=dc[0].y, y=out)",
    "negative_binomial": "\n\ndef NEGATIVE_BINOMIAL(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a negative binomial distribution.\n    \n    Samples are drawn from a negative binomial distribution with specified\n    parameters, `n` successes and `p` probability of success where `n` is an\n    integer > 0 and `p` is in the interval [0, 1].\n    \n    Parameters\n    ----------\n    n : int or array_like of ints\n        Parameter of the distribution, > 0. Floats are also accepted, but they\n        will be truncated to integers.\n    p : float or array_like of floats\n        Parameter of the distribution, >= 0 and <=1.\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    \"\"\"\n    n: int = params.get('n', None)\n    p: float = params.get('p', None)\n    size: int = params.get('size', None)\n    out = np.random.negative_binomial(n, p, size=size, y=dc[0].y)\n    return DataContainer(x=dc[0].y, y=out)",
    "normal": "\n\ndef NORMAL(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw random samples from a normal (Gaussian) distribution.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data points.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    DataContainer\n        Instance of DataContainer with x=dc[0].y, y=random samples from a normal (Gaussian) distribution.\n    \n    \"\"\"\n    mean: float = params.get('mean', 0.0)\n    std: float = params.get('std', 1.0)\n    size: int = params.get('size', None)\n    return DataContainer(x=dc[0].y, y=np.random.normal(dc[0].y, mean, std, size))",
    "logseries": "\n\ndef LOGSERIES(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Logarithmic Series distribution.\n    \n    Samples are drawn from a logarithmic series distribution with specified\n    shape parameter, 0 <= dc[0].y <= 1.\n    \n    Parameters\n    ----------\n    dc[0].y : float or array_like of floats\n        Shape parameter of the distribution. Must be in the range [0, 1].\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    loc : float, optional\n        Location parameter (default=0).\n    scale : float, optional\n        Scale parameter (default=1).\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Raises\n    ------\n    ValueError\n        If dc[0].y is not in the range [0, 1].\n    \"\"\"\n    # Enforce strict typing\n    dc[0].y: float\n    size: Optional[Union[int, Tuple[int, ...]]] = params.get('size', None)\n    loc: float = params.get('loc', 0.0)\n    scale: float = params.get('scale', 1.0)\n    \n    # Check that dc[0].y is in the range [0, 1]\n    if not 0 <= dc[0].y <= 1:\n        raise ValueError('dc[0].y must be in the range [0, 1].')\n    \n    # Draw samples from the logarithmic series distribution\n    out = np.random.logseries(dc[0].y, size=size, loc=loc, scale=scale)\n    \n    # Return a DataContainer instance\n    return DataContainer(x=dc[0].y, y=out)",
    "noncentral_chisquare": "\n\ndef NONCENTRAL_CHISQUARE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a noncentral chi-square distribution.\n    \n    The noncentral :math:`\\chi^2` distribution is a generalisation of\n    the :math:`\\chi^2` distribution. It is used to model the sum of\n    independent chi-square variables, each with different degrees of\n    freedom, but the same non-centrality parameter.\n    \n    Parameters\n    ----------\n    df : float or array_like of floats\n        Degrees of freedom, should be > 0.\n    nonc : float or array_like of floats\n        Non-centrality parameter.  Should be >= 0.\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Raises\n    ------\n    ValueError\n        When `df` or `nonc` is less than zero.\n    \"\"\"\n    df: float = params.get('df', 0.0)\n    nonc: float = params.get('nonc', 0.0)\n    size: tuple = params.get('size', None)\n    \n    if df < 0.0 or nonc < 0.0:\n        raise ValueError('df and nonc must be greater than or equal to 0.')\n    \n    out = np.random.noncentral_chisquare(df, nonc, size=size) * dc[0].y\n    return DataContainer(x=dc[0].y, y=out)",
    "pareto": "\n\ndef PARETO(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Pareto II or Lomax distribution with specified shape.\n    \n    The Lomax or Pareto II distribution is a shifted Pareto\n    distribution. The classical Pareto distribution can be obtained\n    from the Lomax distribution by adding 1 and multiplying by the\n    scale parameter m.\n    \n    Parameters\n    ----------\n    dc : list\n        List of length 1 containing the shape parameter of the distribution.\n    params : dict\n        Dictionary containing the optional parameters of the distribution.\n        The keys of the dictionary must be the same as the optional\n        parameters of the function.\n    \n    Returns\n    -------\n    DataContainer\n        An instance of the DataContainer class, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    # Strictly type all internal variables\n    shape: float = dc[0].y\n    size: Optional[tuple] = params.get('size', None)\n    loc: Optional[float] = params.get('loc', 0.0)\n    scale: Optional[float] = params.get('scale', 1.0)\n    random_state: Optional[int] = params.get('random_state', None)\n    \n    # Draw samples from the Pareto II or Lomax distribution\n    out = np.random.pareto(shape, size=size, loc=loc, scale=scale, random_state=random_state)\n    return DataContainer(x=dc[0].y, y=out)",
    "multivariate_normal": "\n\ndef MULTIVARIATE_NORMAL(dc: dict, params: dict) -> DataContainer:\n    \"\"\"Draw random samples from a multivariate normal distribution.\n    \n    The multivariate normal, multinormal or Gaussian distribution is a generalization\n    of the one-dimensional normal distribution to higher dimensions. Such a distribution\n    is specified by its mean and covariance matrix. These parameters are analogous to\n    the mean (average or “center”) and variance (standard deviation, or “width,” squared)\n    of the one-dimensional normal distribution.\n    \n    Parameters\n    ----------\n    dc : dict\n        Dictionary containing the mean and covariance matrix of the distribution.\n    params : dict\n        Optional keyword arguments.\n    \n    Returns\n    -------\n    out : DataContainer\n        The drawn samples, of shape (n, d) where d is the dimension of the mean, instantiated with the arguments 'x=dc[0].y, y=<out>'.\n    \n    Examples\n    --------\n    >>> mean = [0, 0]\n    >>> cov = [[1, 0], [0, 100]]  # diagonal covariance\n    >>> x = MULTIVARIATE_NORMAL(dc={'mean': mean, 'cov': cov}, params={})\n    >>> x.shape\n    (2, 2)\n    \"\"\"\n    mean = dc[0]['mean']\n    cov = dc[0]['cov']\n    size = params.get('size', None)\n    check_valid = params.get('check_valid', 'warn')\n    tol = params.get('tol', 1e-8)\n    out = np.random.multivariate_normal(mean, cov, size, check_valid, tol)\n    return DataContainer(x=dc[0].y, y=out)",
    "permutation": "\n\ndef PERMUTATION(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Randomly permute a sequence, or return a permuted range.\n    \n    Parameters\n    ----------\n    x : int or array_like\n        If `x` is an integer, randomly permute np.arange(x). If `x` is an\n        array, make a copy and shuffle the elements randomly.\n    axis : int, optional\n        The axis along which to permute the sequence. By default, use the\n        whole array or sequence.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Examples\n    --------\n    >>> np.random.permutation(10)\n    array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6])\n    \n    >>> np.random.permutation([1, 4, 9, 12, 15])\n    array([15,  1,  9,  4, 12])\n    \"\"\"\n    x: Union[int, np.ndarray] = dc[0].y\n    axis: Optional[int] = params.get('axis', None)\n    out: np.ndarray = np.random.permutation(x, axis=axis)\n    return DataContainer(x=dc[0].y, y=out)",
    "poisson": "\n\ndef POISSON(dc: list, params: dict) -> DataContainer:\n    \"\"\"Draw samples from a Poisson distribution.\n    \n    Samples are drawn from a Poisson distribution with specified\n    parameters, where both the mean and the variance are equal to\n    `dc[0].y`.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data points.\n    params : dict\n        Dictionary of optional parameters.\n        \n    Returns\n    -------\n    DataContainer\n        DataContainer instance with x=dc[0].y, y=drawn samples from the Poisson distribution.\n        \n    \"\"\"\n    # Enforce strict typing\n    dc: list = dc\n    params: dict = params\n    \n    # Extract primary argument\n    y: float = dc[0].y\n    \n    # Extract optional arguments\n    size: int = params.get('size', None)\n    loc: float = params.get('loc', 0.0)\n    random_state: int = params.get('random_state', None)\n    \n    # Draw samples from the Poisson distribution\n    out = np.random.poisson(lam=y, size=size, loc=loc, random_state=random_state)\n    \n    # Return custom class\n    return DataContainer(x=dc[0].y, y=out)",
    "rand": "\n\ndef RAND(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Random values in a given shape.\n    \n    Create an array of the given shape and populate it with\n    random samples from a uniform distribution\n    over ``[0, 1)``.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance with x=dc[0].y, y=random values in a given shape.\n    \n    Examples\n    --------\n    >>> np.random.rand(3,2)\n    array([[0.10, 0.82],\n           [0.71, 0.21],\n           [0.63, 0.91]])\n    \"\"\"\n    # Strictly typed internal variables\n    shape: tuple = params.get('shape', dc[0].y)\n    dtype: type = params.get('dtype', float)\n    out: float = np.random.rand(shape, dtype=dtype)\n    return DataContainer(x=dc[0].y, y=out)",
    "power": "\n\ndef POWER(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Power distribution.\n    \n    Samples are drawn from a Power distribution with specified shape parameter,\n    a, where 0 < a <= 2.\n    \n    Parameters\n    ----------\n    a : float or array_like of floats\n        Shape parameter of the distribution. Must be strictly greater than 0 and\n        less than or equal to 2.\n    size : int or tuple of ints, optional\n        Output shape. If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn. Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Raises\n    ------\n    ValueError\n        If `a` is not in the range (0, 2].\n    \"\"\"\n    a = params.get('a', None)\n    size = params.get('size', None)\n    \n    if not isinstance(a, float) or a <= 0 or a > 2:\n        raise ValueError('a must be a float strictly greater than 0 and less than or equal to 2.')\n    if not isinstance(size, int) and not isinstance(size, tuple):\n        raise ValueError('size must be an int or a tuple of ints.')\n    \n    out = np.random.power(dc[0].y, a, size)\n    return DataContainer(x=dc[0].y, y=out)",
    "noncentral_f": "\n\ndef NONCENTRAL_F(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from the noncentral F distribution.\n    \n    Samples are drawn from an F distribution with specified parameters,\n    `dfn` and `dfd`, where both parameters should be greater than zero.\n    `nonc` is the non-centrality parameter.\n    \n    Parameters\n    ----------\n    dfn : float\n        Degrees of freedom of the numerator. Should be greater than zero.\n    dfd : float\n        Degrees of freedom of the denominator. Should be greater than zero.\n    nonc : float\n        Non-centrality parameter. Should be greater than or equal to zero.\n    size : int or tuple of ints, optional\n        Output shape. If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn. Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    samples : DataContainer\n        The drawn samples, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    dfn = params.get('dfn', None)\n    dfd = params.get('dfd', None)\n    nonc = params.get('nonc', None)\n    size = params.get('size', None)\n    if dfn is None or dfd is None or nonc is None:\n        raise ValueError('dfn, dfd, and nonc must all be specified.')\n    if not isinstance(dfn, float) or not isinstance(dfd, float) or not isinstance(nonc, float):\n        raise TypeError('dfn, dfd, and nonc must all be floats.')\n    if dfn <= 0 or dfd <= 0 or nonc < 0:\n        raise ValueError('dfn, dfd, and nonc must all be greater than zero.')\n    out = np.random.noncentral_f(dfn, dfd, nonc, size=size)\n    return DataContainer(x=dc[0].y, y=out)",
    "random": "\n\ndef RANDOM(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Random values in a given shape.\n    \n    Create an array of the given shape and populate it with\n    random samples from a uniform distribution\n    over ``[0, 1)``.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of optional parameters.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance with x=dc[0].y, y=random values in a given shape.\n    \n    Examples\n    --------\n    >>> np.random.random((2,2))\n    array([[0.1046, 0.4585],\n           [0.4298, 0.6789]])\n    \"\"\"\n    shape = params.get('shape', dc[0].y)\n    out = np.random.random(shape)\n    return DataContainer(x=dc[0].y, y=out)",
    "seed": "\n    return DataContainer(x=dc[0].y, y=out)",
    "ranf": "\n\ndef RANF(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Random values in a given shape.\n    Create an array of the given shape and populate it with\n    random samples from a uniform distribution\n    over ``[0, 1)``.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance with x=dc[0].y, y=random values in a given shape.\n    \"\"\"\n    # Strictly typed internal variables\n    shape: tuple = params.get('shape', None)\n    size: int = params.get('size', None)\n    low: float = params.get('low', 0.0)\n    high: float = params.get('high', 1.0)\n    dtype: type = params.get('dtype', None)\n    out = np.random.ranf(dc[0].y, shape=shape, size=size, low=low, high=high, dtype=dtype)\n    return DataContainer(x=dc[0].y, y=out)",
    "sample": "\n\ndef SAMPLE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a uniform distribution.\n    \n    Samples are uniformly distributed over the half-open interval\n    ``[low, high)`` (includes low, but excludes high). In other words,\n    any value within the given interval is equally likely to be drawn\n    by `numpy.random.sample`.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of optional parameters.\n    \n    Returns\n    -------\n    DataContainer\n        DataContainer instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    \"\"\"\n    low: float = params.get('low', 0.0)\n    high: float = params.get('high', 1.0)\n    size: int = params.get('size', None)\n    out = np.random.sample(dc[0].y, low=low, high=high, size=size)\n    return DataContainer(x=dc[0].y, y=out)",
    "set_state": "\n\ndef SET_STATE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Set the internal state of the random number generator.\n\n    Parameters\n    ----------\n    dc : list\n        List of `RandomState` objects.\n    params : dict\n        Dictionary of parameters.\n\n    Returns\n    -------\n    DataContainer\n        An instance of the DataContainer class, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n\n    \"\"\"\n    state = params.get('state', None)\n    pos = params.get('pos', None)\n    has_gauss = params.get('has_gauss', None)\n    cached_gaussian = params.get('cached_gaussian', None)\n\n    if state is None or pos is None or has_gauss is None or cached_gaussian is None:\n        raise ValueError('All parameters must be provided.')\n\n    out = dc[0].y.random.set_state(state, pos, has_gauss, cached_gaussian)\n    return DataContainer(x=dc[0].y, y=out)",
    "randn": "\n\ndef RANDN(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Return a sample (or samples) from the \"standard normal\" distribution.\n    \n    If dc[0].y is a float, a single float is returned.\n    If dc[0].y is a tuple, a tuple of floats is returned.\n    \n    Parameters\n    ----------\n    dc[0].y : float or tuple of floats\n        The shape of the output.\n    params : dict\n        Optional keyword arguments, taken as keys of the same name from the dictionary 'params'.\n        These include:\n        size : int or tuple of ints, optional\n            Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned.\n        dtype : {'float16', 'float32', 'float64'}, optional\n            Desired dtype of the result. All dtypes are determined by their\n            name, i.e., 'float32' will be 32 bits.\n        out : ndarray, optional\n            Alternative output array in which to place the result. It must have\n            the same shape and buffer length as the expected output, but the\n            type (of the output) will be cast if necessary.\n\n    Returns\n    -------\n    out : DataContainer\n        A DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    \"\"\"\n    size: int = params.get('size', None)\n    dtype: str = params.get('dtype', 'float64')\n    out: np.ndarray = params.get('out', None)\n    \n    return DataContainer(x=dc[0].y, y=np.random.randn(dc[0].y, size=size, dtype=dtype, out=out))",
    "shuffle": "\n\ndef SHUFFLE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Shuffle the sequence x in place.\n\n    Parameters\n    ----------\n    dc : list\n        List of data objects.\n    params : dict\n        Dictionary of optional parameters.\n\n    Returns\n    -------\n    DataContainer\n        The sequence is shuffled in place and returned as a DataContainer object.\n\n    \"\"\"\n    x: np.ndarray = dc[0].y\n    axis: int = params.get('axis', -1)\n    random_state: Union[int, np.random.RandomState] = params.get('random_state', None)\n    np.random.shuffle(x, axis=axis, random_state=random_state)\n    return DataContainer(x=dc[0].y, y=x)",
    "": "",
    "randint": "\n\ndef RANDINT(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Random integers from `low` (inclusive) to `high` (exclusive).\n    \n    Return random integers from the \"discrete uniform\" distribution in the\n    \"half-open\" interval [`low`, `high`). If `high` is None (the default),\n    then results are from [0, `low`).\n    \n    Parameters\n    ----------\n    low : int\n        Lowest (signed) integer to be drawn from the distribution (unless\n        ``high=None``, in which case this parameter is one above the\n        *highest* such integer).\n    high : int, optional\n        If provided, one above the largest (signed) integer to be drawn\n        from the distribution (see above for behavior if ``high=None``).\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Examples\n    --------\n    >>> np.random.randint(2, size=10)\n    array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])\n    >>> np.random.randint(1, size=10)\n    array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    \n    Generate a 2 x 4 array of ints between 0 and 4, inclusive:\n    \n    >>> np.random.randint(5, size=(2, 4))\n    array([[4, 0, 2, 1],\n           [3, 2, 2, 0]])\n    \"\"\"\n    low: int = dc[0].y\n    high: int = params.get('high', None)\n    size: int = params.get('size', None)\n    out = np.random.randint(low, high, size)\n    return DataContainer(x=dc[0].y, y=out)",
    "random_integers": "\n\ndef RANDOM_INTEGERS(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Random integers of type np.int between low and high, inclusive.\n    \n    Return random integers of type np.int from the “discrete uniform”\n    distribution in the closed interval [low, high]. If high is None (the\n    default), then results are from [0, low].\n    \n    Parameters\n    ----------\n    dc[0].y : int\n        Lowest (signed) integer to be drawn from the distribution (unless\n        ``high=None``, in which case this parameter is the highest such\n        integer).\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    high : int, optional\n        If provided, one above the largest (signed) integer to be drawn\n        from the distribution (see above for behavior if ``high=None``).\n\n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Raises\n    ------\n    ValueError\n        If ``low >= high``, if ``high < 0`` or if ``low > np.iinfo(np.int).max``.\n    \"\"\"\n    low: int = dc[0].y\n    size: int = params.get('size', None)\n    high: int = params.get('high', None)\n    \n    out = np.random.random_integers(low, high, size)\n    return DataContainer(x=dc[0].y, y=out)",
    "standard_cauchy": "\n\ndef STANDARD_CAUCHY(dc: List[float], params: Dict[str, Any]) -> DataContainer:\n    \"\"\"\n    Draw samples from a standard Cauchy distribution with mode = 0.\n    \n    The standard Cauchy distribution has density::\n    \n        f(x) = 1 / (pi * (1 + x**2))\n    \n    Parameters\n    ----------\n    dc : List[float]\n        The primary argument of the function.\n    params : Dict[str, Any]\n        All optional arguments taken as keys of the same name from the dictionary.\n    \n    Returns\n    -------\n    DataContainer\n        An instance of the DataContainer class, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    loc: float = params.get('loc', 0.0)\n    size: Optional[int] = params.get('size', None)\n    out = np.random.standard_cauchy(dc[0].y, loc=loc, size=size)\n    return DataContainer(x=dc[0].y, y=out)",
    "standard_gamma": "\n\ndef STANDARD_GAMMA(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Gamma distribution.\n    \n    Samples are drawn from a Gamma distribution with specified parameters,\n    shape (sometimes designated \"k\") and scale (sometimes designated\n    \"theta\"), where both parameters are > 0.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    DataContainer\n        Instance of DataContainer with x=dc[0].y, y=drawn samples from the parameterized Gamma distribution.\n    \n    \"\"\"\n    shape: float = params.get('shape', 1.0)\n    scale: float = params.get('scale', 1.0)\n    size: tuple = params.get('size', None)\n    return DataContainer(x=dc[0].y, y=np.random.standard_gamma(dc[0].y, shape, scale, size))",
    "standard_t": "\n\ndef STANDARD_T(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a standard Student’s t distribution with df degrees of freedom.\n    \n    Parameters\n    ----------\n    df : int or array_like of ints\n        Degrees of freedom, must be > 0.\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    df: int = params.get('df', None)\n    size: tuple = params.get('size', None)\n    return DataContainer(x=dc[0].y, y=np.random.standard_t(df, size=size, dc[0].y))",
    "random_sample": "\n\ndef RANDOM_SAMPLE(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Random values in a given shape.\n    \n    Create an array of the given shape and populate it with\n    random samples from a uniform distribution\n    over ``[0, 1)``.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    out : DataContainer\n        Random values.\n    \n    Optional Parameters\n    ------------------\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    dtype : str, optional\n        Desired dtype of the result. All dtypes are determined by their\n        name, i.e., 'float64', 'int', etc.\n    out : ndarray, optional\n        If provided, the result will be placed in this array. It should\n        be of the appropriate shape and dtype.\n    \n    Examples\n    --------\n    >>> np.random.random_sample(dc[0].y)\n    DataContainer(x=dc[0].y, y=array([0.5488135 , 0.71518937, 0.60276338, 0.54488318, 0.4236548 ]))\n    \"\"\"\n    size = params.get('size', None)\n    dtype = params.get('dtype', 'float64')\n    out = params.get('out', None)\n    \n    return DataContainer(x=dc[0].y, y=np.random.random_sample(dc[0].y, size=size, dtype=dtype, out=out))",
    "rayleigh": "\n\ndef RAYLEIGH(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Rayleigh distribution.\n    \n    The :math:`\\chi` and Weibull distributions are generalizations of the\n    Rayleigh.\n    \n    Parameters\n    ----------\n    dc[0].y : float or array_like of floats\n        The mode of the distribution.\n    scale : float or array_like of floats, optional\n        The scale parameter, :math:`\\sigma`.  Must be non-negative.\n        Default is 1.\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Notes\n    -----\n    The probability density function for the Rayleigh distribution is\n    \n    .. math:: P(x;scale) = \\frac{x}{scale^2}e^{\\frac{-x^2}{2 \\cdotp scale^2}}\n    \n    The Rayleigh distribution is just the special case where the\n    exponential distribution has a scale parameter of 1.\n    \n    References\n    ----------\n    .. [1] Brighton Webs Ltd., \"Rayleigh Distribution,\"\n           https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp\n    .. [2] Wikipedia, \"Rayleigh distribution\"\n           https://en.wikipedia.org/wiki/Rayleigh_distribution\n    \n    Examples\n    --------\n    Draw values from the distribution and plot the histogram\n    \n    >>> from numpy.random import rayleigh\n    >>> import matplotlib.pyplot as plt\n    >>> values = rayleigh(5, scale=3, size=10000)\n    >>> plt.hist(values, bins=50, density=True)\n    >>> plt.show()\n    \n    \"\"\"\n    scale: float = params.get('scale', 1.0)\n    size: Union[int, Tuple[int, ...]] = params.get('size', None)\n    out = np.random.rayleigh(dc[0].y, scale=scale, size=size)\n    return DataContainer(x=dc[0].y, y=out)",
    "vonmises": "\n\ndef VONMISES(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a von Mises distribution.\n    \n    Samples are drawn from a von Mises distribution with specified mode (mu)\n    and dispersion (kappa), on the interval [-pi, pi].\n    \n    The von Mises distribution (also known as the circular normal\n    distribution) is a continuous probability distribution on the unit circle.\n    \n    Parameters\n    ----------\n    dc : list\n        List of length 1 containing the mode (mu) of the von Mises distribution.\n    params : dict\n        Dictionary containing the dispersion (kappa) of the von Mises distribution.\n    \n    Returns\n    -------\n    DataContainer\n        Instance of DataContainer with x=dc[0].y, y=random variates from the von Mises distribution.\n    \"\"\"\n    mu = dc[0].y\n    kappa = params['kappa']\n    return DataContainer(x=dc[0].y, y=np.random.vonmises(mu, kappa))",
    "wald": "\n\ndef WALD(dc: list, params: dict) -> DataContainer:\n    \"\"\"Draw samples from a Wald, or inverse Gaussian, distribution.\n    \n    Samples are drawn from a Wald, or inverse Gaussian, distribution with\n    specified mean and scale parameters.\n    \n    Parameters\n    ----------\n    dc : list\n        List of length 1 containing the mean of the distribution.\n    params : dict\n        Dictionary containing the scale parameter of the distribution.\n    \n    Returns\n    -------\n    DataContainer\n        Instance of DataContainer with x=dc[0].y, y=samples drawn from the Wald distribution.\n    \n    \"\"\"\n    mean: float = dc[0].y\n    scale: float = params.get('scale', 1.0)\n    return DataContainer(x=dc[0].y, y=np.random.wald(mean, scale))",
    "triangular": "\n\ndef TRIANGULAR(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from the triangular distribution over the interval [left, right].\n    \n    The triangular distribution is a continuous probability distribution with lower limit left, peak at mode, and upper limit right. Unlike the other distributions, these parameters directly define the shape of the distribution.\n    \n    Parameters\n    ----------\n    left : float or array_like of floats\n        Lower limit.\n    mode : float or array_like of floats\n        The value where the peak of the distribution occurs. The value should fulfill the condition ``left <= mode <= right``.\n    right : float or array_like of floats\n        Upper limit, should be larger than `left`.\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Raises\n    ------\n    ValueError\n        If `left > mode` or `mode > right`.\n    \"\"\"\n    left: float = params.get('left', 0.0)\n    mode: float = params.get('mode', 0.0)\n    right: float = params.get('right', 1.0)\n    size: int = params.get('size', None)\n    \n    out = np.random.triangular(left, mode, right, size=size, dc[0].y)\n    return DataContainer(x=dc[0].y, y=out)",
    "weibull": "\n\ndef WEIBULL(dc: list, params: dict) -> DataContainer:\n    \"\"\"Draw samples from a Weibull distribution.\n    \n    Draw samples from a 1-parameter Weibull distribution with given shape parameter\n    a, and scale parameter loc.\n    \n    Parameters\n    ----------\n    a : float or array_like of floats\n        Shape parameter of the distribution. Must be non-negative.\n    loc : float or array_like of floats, optional\n        Location parameter of the distribution. Default is 0.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \"\"\"\n    a = params.get('a', 0.0)\n    loc = params.get('loc', 0.0)\n    out = np.random.weibull(a, loc) * dc[0].y\n    return DataContainer(x=dc[0].y, y=out)",
    "standard_exponential": "\n\ndef STANDARD_EXPONENTIAL(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a standard exponential distribution.\n    \n    Its probability density function is\n    \n    .. math:: f(x; \\lambda) = \\lambda e^{-\\lambda x}\n    \n    for ``x > 0`` and 0 elsewhere. :math:`\\lambda` is the rate parameter,\n    which is the inverse of the scale parameter :math:`\\beta = 1/\\lambda`.\n    The rate parameter is an alternative, widely used parameterization\n    of the exponential distribution [3]_.\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    DataContainer\n        Instance of DataContainer with x=dc[0].y, y=drawn samples from the parameterized standard exponential distribution.\n    \n    Examples\n    --------\n    Draw samples from the standard exponential distribution:\n    \n    >>> from numpy.random import standard_exponential\n    >>> s = standard_exponential(dc[0].y, params)\n    \n    References\n    ----------\n    .. [1] Wikipedia, \"Exponential distribution\",\n           https://en.wikipedia.org/wiki/Exponential_distribution\n    .. [2] Reiss, R.-D. and Thomas, M. (2019). Statistical Analysis and\n           Data Mining Specializations, \"Exponential Distribution\",\n           https://statisticalanalysisanddatamining.com/exponential-distribution/\n    .. [3] NIST/SEMATECH e-Handbook of Statistical Methods, \"Exponential\n           Distribution\",\n           https://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm\n    \"\"\"\n    rate: float = params.get('rate', 1.0)\n    size: int = params.get('size', None)\n    out = np.random.standard_exponential(dc[0].y, rate, size)\n    return DataContainer(x=dc[0].y, y=out)",
    "zipf": "\n\ndef ZIPF(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a Zipf distribution.\n    \n    Samples are drawn from a Zipf distribution with specified parameters \n    a (distribution shape) and N (number of elements to draw).\n    \n    Parameters\n    ----------\n    dc : list\n        List of data points.\n    params : dict\n        Dictionary of parameters.\n        a : float or array_like of floats\n            Distribution shape. Should be greater than 1.\n        N : int\n            Number of samples to draw.\n    \n    Returns\n    -------\n    samples : DataContainer\n        The drawn samples, instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Raises\n    ------\n    ValueError\n        If `a` is not greater than 1.\n    \"\"\"\n    a = params.get('a', 1.0)\n    N = params.get('N', 1)\n    \n    if a <= 1:\n        raise ValueError('a must be greater than 1')\n    \n    out = np.random.zipf(a, N, dc[0].y)\n    return DataContainer(x=dc[0].y, y=out)",
    "uniform": "\n\ndef UNIFORM(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw samples from a uniform distribution.\n    \n    Samples are uniformly distributed over the half-open interval\n    ``[low, high)`` (includes low, but excludes high).  In other words,\n    any value within the given interval is equally likely to be drawn\n    by `uniform`.\n    \n    Parameters\n    ----------\n    low : float or array_like of floats\n        Lower boundary of the output interval.  All values generated will be\n        greater than or equal to low.  The default value is 0.\n    high : float or array_like of floats\n        Upper boundary of the output interval.  All values generated will be\n        less than high.  The default value is 1.0.\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Raises\n    ------\n    ValueError\n        If any of the parameters are invalid.\n    \n    See Also\n    --------\n    scipy.stats.uniform : probability density function, distribution or\n        cumulative density function, etc.\n    \n    Notes\n    -----\n    The probability density for the uniform distribution is\n    \n    .. math:: p(x) = \\frac{1}{b - a}\n    \n    anywhere within the interval ``[a, b)``, and zero elsewhere.\n    \n    Examples\n    --------\n    Draw samples from the uniform distribution:\n    \n    >>> np.random.uniform(0, 10, size=(3, 2))\n    array([[3.99149989, 4.68521956],  # random\n           [2.23439331, 4.71556609],  # random\n           [0.54194485, 5.33249845]]) # random\n    \"\"\"\n    low = params.get('low', 0)\n    high = params.get('high', 1.0)\n    size = params.get('size', None)\n    \n    if not isinstance(low, (float, int)):\n        raise ValueError('low must be a float or int')\n    if not isinstance(high, (float, int)):\n        raise ValueError('high must be a float or int')\n    if not isinstance(size, (int, tuple)):\n        raise ValueError('size must be an int or tuple')\n    \n    out = np.random.uniform(low, high, size=size)\n    return DataContainer(x=dc[0].y, y=out)",
    "standard_normal": "\n\ndef STANDARD_NORMAL(dc: list, params: dict) -> DataContainer:\n    \"\"\"\n    Draw random samples from a normal (Gaussian) distribution.\n    \n    The probability density function of the normal distribution, first\n    derived by De Moivre and 200 years later by both Gauss and Laplace\n    independently [2]_, is often called the bell curve because of\n    its characteristic shape (see the example below).\n    \n    Parameters\n    ----------\n    dc : list\n        List of data containers.\n    params : dict\n        Dictionary of parameters.\n    \n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Optional Parameters\n    -------------------\n    size : int or tuple of ints, optional\n        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n        ``m * n * k`` samples are drawn.  Default is None, in which case a\n        single value is returned.\n    loc : float or array_like of floats, optional\n        Mean (“centre”) of the distribution.\n    scale : float or array_like of floats, optional\n        Standard deviation (spread or “width”) of the distribution.\n    Returns\n    -------\n    out : DataContainer\n        DataContainer instance instantiated with the arguments 'x=dc[0].y, y=<out>', where <out> is the return value of the function.\n    \n    Notes\n    -----\n    The probability density for the Gaussian distribution is\n    \n    .. math:: p(x) = \\frac{1}{\\sqrt{ 2 \\pi \\sigma^2 }}\n                     e^{ - \\frac{ (x - \\mu)^2 } {2 \\sigma^2} },\n    \n    where :math:`\\mu` is the mean and :math:`\\sigma` the standard\n    deviation. The square of the standard deviation, :math:`\\sigma^2`,\n    is called the variance.\n    \n    The function has its peak at the mean, and its “spread” increases with\n    the standard deviation (the function reaches 0.607 times its maximum at\n    :math:`x + \\sigma` and :math:`x - \\sigma` [2]_).  This implies that\n    `numpy.random.normal` is more likely to return samples lying close to\n    the mean, rather than those far away.\n    \n    References\n    ----------\n    .. [1] Wikipedia, \"Normal distribution\",\n           https://en.wikipedia.org/wiki/Normal_distribution\n    .. [2] P. R. Peebles Jr., \"Central Limit Theorem\" in \"Probability,\n           Random Variables and Random Signal Principles\", 4th ed., 2001,\n           pp. 51, 51, 125.\n    \n    Examples\n    --------\n    Draw samples from the distribution:\n    \n    >>> mu, sigma = 0, 0.1 # mean and standard deviation\n    >>> s = np.random.normal(mu, sigma, 1000)\n    \n    Verify the mean and the variance:\n    \n    >>> abs(mu - np.mean(s)) < 0.01\n    True\n    \n    >>> abs(sigma - np.std(s, ddof=1)) < 0.01\n    True\n    \n    Display the histogram of the samples, along with\n    the probability density function:\n    \n    >>> import matplotlib.pyplot as plt\n    >>> count, bins, ignored = plt.hist(s, 30, density=True)\n    >>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n    ...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n    ...          linewidth=2, color='r')\n    >>> plt.show()\n    \"\"\"\n    # Strictly type all internal variables\n    size: Optional[Union[int, Tuple[int, ...]]] = params.get('size', None)\n    loc: Optional[Union[float, np.ndarray]] = params.get('loc', None)\n    scale: Optional[Union[float, np.ndarray]] = params.get('scale', None)\n    \n    # Primary argument of the function\n    out = np.random.standard_normal(size=size, loc=loc, scale=scale, dc[0].y)\n    \n    return DataContainer(x=dc[0].y, y=out)"
}