{
  "description": "This node is designed to be used in a loop. The data is appended as the loop progresses and written to memory.\n\nInputs\n------\ndefault : Scalar\n    PID node output.",
  "parameters": [
    {
      "name": "d1",
      "type": "float",
      "description": "The first time constant."
    },
    {
      "name": "d2",
      "type": "float",
      "description": "The second time constant."
    }
  ],
  "returns": [
    {
      "name": null,
      "type": "Scalar",
      "description": "The most recent value of the second order function."
    }
  ],
  "code": "from numpy import exp, ndarray, insert, zeros\nfrom flojoy import flojoy, OrderedPair, DefaultParams, SmallMemory, Vector, Scalar\n\n\nmemory_key = \"SECOND_ORDER_SYSTEM\"\n\n\n@flojoy(inject_node_metadata=True)\ndef SECOND_ORDER_SYSTEM(\n    default: OrderedPair | Vector | Scalar,\n    default_params: DefaultParams,\n    d1: float = 250,\n    d2: float = 100,\n) -> OrderedPair:\n    \"\"\"The SECOND_ORDER_SYSTEM has a second order exponential function.\n\n    This node is designed to be used in a loop. The data is appended as the loop progresses and written to memory.\n\n    Inputs\n    ------\n    default : Scalar\n        PID node output.\n\n    Parameters\n    ----------\n    d1 : float\n        The first time constant.\n    d2 : float\n        The second time constant.\n    Returns\n    -------\n    Scalar\n        The most recent value of the second order function.\n    \"\"\"\n\n    # Let's first define things that won't change over\n    # each iteration: time constants, etc ...\n    def_key = default.c\n\n    node_id = default_params.node_id\n\n    # ... and now some helper functions\n    x1 = exp(-1.0 / d1) if d1 > 0 else 0.0\n    x2 = exp(-1.0 / d2) if d2 > 0 else 0.0\n    ac = (1.0 - x1) * (1.0 - x2)\n    bpd = x1 + x2\n    bd = x1 * x2\n\n    # Now we require memory. The only thing we need in memory is the last two\n    # values the system had in this basic example.\n    data = SmallMemory().read_memory(node_id, memory_key)\n    if data is None:\n        initialize = True\n    elif type(data) == ndarray:\n        initialize = False\n    else:\n        raise TypeError(f\"Error loading object from REDIS. Type: {type(data)}\")\n\n    # We're going to store and read the data in reverse order to\n    # how it is accessed here. We will write the functionality\n    # below to assume the most recent time step is the first\n    # index. However, for visualization and external access,\n    # it makes the most sense to have the first time step\n    # as the first index!\n    y_primes = zeros((2, 1)) if initialize else data[::-1]\n\n    # Using input from controller as v[0].y ...\n    response = ac * def_key + bpd * y_primes[0] - bd * y_primes[1]\n    y_primes[1] = y_primes[0]\n\n    # prepend the most recent result to the front of the histrory\n    y_primes = insert(y_primes, 0, response)\n    # We now write to memory, reversing the order ...\n    SmallMemory().write_to_memory(node_id, memory_key, y_primes[::-1])\n    # ... and return the result!\n    return Scalar(float(y_primes[0]))  # returns input output pair\n"
}