{
  "description": "The DataContainer input type must be a dataframe, and the first column (or index) of the dataframe must be of a datetime type.\n\nThis node always returns a DataContainer of a dataframe type. It will also always return an 'extra' field with a key 'prophet' of which the value is the JSONified Prophet model.\nThis model can be loaded as follows:\n\n    ```python\n    from prophet.serialize import model_from_json\n\n    model = model_from_json(dc_inputs.extra[\"prophet\"])\n    ```",
  "parameters": [
    {
      "name": "run_forecast",
      "type": "bool",
      "description": "If True (default case), the dataframe of the returning DataContainer\n('m' parameter of the DataContainer) will be the forecasted dataframe.\nIt will also have an 'extra' field with the key 'original', which is\nthe original dataframe passed in.\n\nIf False, the returning dataframe will be the original data.\n\nThis node will also always have an 'extra' field, run_forecast, which\nmatches that of the parameters passed in. This is for future nodes\nto know if a forecast has already been run.\n\nDefault = True"
    },
    {
      "name": "periods",
      "type": "int",
      "description": "The number of periods to predict out. Only used if run_forecast is True.\nDefault = 365"
    }
  ],
  "returns": [
    {
      "name": null,
      "type": "DataFrame",
      "description": "With parameter as df.\nIndicates either the original df passed in, or the forecasted df\n(depending on if run_forecast is True)."
    },
    {
      "name": null,
      "type": "DataContainer",
      "description": "With parameter as 'extra'.\nContains keys run_forecast which correspond to the input parameter,\nand potentially 'original' in the event that run_forecast is True."
    }
  ],
  "code": "from flojoy import flojoy, run_in_venv, DataFrame\n\n\n@flojoy\n@run_in_venv(\n    pip_dependencies=[\n        \"prophet==1.1.5\",\n    ]\n)\ndef PROPHET_PREDICT(\n    default: DataFrame, run_forecast: bool = True, periods: int = 365\n) -> DataFrame:\n    \"\"\"The PROPHET_PREDICT node runs a Prophet model on the incoming dataframe.\n\n    The DataContainer input type must be a dataframe, and the first column (or index) of the dataframe must be of a datetime type.\n\n    This node always returns a DataContainer of a dataframe type. It will also always return an 'extra' field with a key 'prophet' of which the value is the JSONified Prophet model.\n    This model can be loaded as follows:\n\n        ```python\n        from prophet.serialize import model_from_json\n\n        model = model_from_json(dc_inputs.extra[\"prophet\"])\n        ```\n\n    Parameters\n    ----------\n    run_forecast : bool\n        If True (default case), the dataframe of the returning DataContainer\n        ('m' parameter of the DataContainer) will be the forecasted dataframe.\n        It will also have an 'extra' field with the key 'original', which is\n        the original dataframe passed in.\n\n        If False, the returning dataframe will be the original data.\n\n        This node will also always have an 'extra' field, run_forecast, which\n        matches that of the parameters passed in. This is for future nodes\n        to know if a forecast has already been run.\n\n        Default = True\n\n    periods : int\n        The number of periods to predict out. Only used if run_forecast is True.\n        Default = 365\n\n    Returns\n    -------\n    DataFrame\n        With parameter as df.\n        Indicates either the original df passed in, or the forecasted df\n        (depending on if run_forecast is True).\n\n    DataContainer\n        With parameter as 'extra'.\n        Contains keys run_forecast which correspond to the input parameter,\n        and potentially 'original' in the event that run_forecast is True.\n    \"\"\"\n\n    import os\n    import sys\n    import pandas as pd\n    import numpy as np\n\n    import prophet\n    from prophet.serialize import model_to_json\n\n    def _make_dummy_dataframe_for_prophet():\n        \"\"\"Generate random time series data to test if prophet works\"\"\"\n        start_date = pd.Timestamp(\"2023-01-01\")\n        end_date = pd.Timestamp(\"2023-07-20\")\n        num_days = (end_date - start_date).days + 1\n        timestamps = pd.date_range(start=start_date, end=end_date, freq=\"D\")\n        data = np.random.randn(num_days)  # Random data points\n        df = pd.DataFrame({\"ds\": timestamps, \"ys\": data})\n        df.rename(\n            columns={df.columns[0]: \"ds\", df.columns[1]: \"y\"}, inplace=True\n        )  # PROPHET model expects first column to be `ds` and second to be `y`\n        return df\n\n    def _apply_macos_prophet_hotfix():\n        \"\"\"This is a hotfix for MacOS. See https://github.com/facebook/prophet/issues/2250#issuecomment-1559516328 for more detail\"\"\"\n\n        if not sys.platform == \"darwin\":\n            return\n\n        # Test if prophet works (i.e. if the hotfix had already been applied)\n        try:\n            _dummy_df = _make_dummy_dataframe_for_prophet()\n            prophet.Prophet().fit(_dummy_df)\n        except RuntimeError as e:\n            print(f\"Could not run prophet, applying hotfix...\")\n        else:\n            return\n\n        prophet_dir = prophet.__path__[0]  # type: ignore\n        # Get stan dir\n        stan_dir = os.path.join(prophet_dir, \"stan_model\")\n        # Find cmdstan-xxxxx dir\n        cmdstan_basename = [x for x in os.listdir(stan_dir) if x.startswith(\"cmdstan\")]\n        assert len(cmdstan_basename) == 1, \"Could not find cmdstan dir\"\n        cmdstan_basename = cmdstan_basename[0]\n        # Run (from stan_dir) : install_name_tool -add_rpath @executable_path/<CMDSTAN_BASENAME>/stan/lib/stan_math/lib/tbb prophet_model.bin\n        cmd = f\"install_name_tool -add_rpath @executable_path/{cmdstan_basename}/stan/lib/stan_math/lib/tbb prophet_model.bin\"\n        cwd = os.getcwd()\n        os.chdir(stan_dir)\n        return_code = os.system(cmd)\n        os.chdir(cwd)\n        if return_code != 0:\n            raise RuntimeError(\"Could not apply hotfix\")\n\n    _apply_macos_prophet_hotfix()\n\n    df = default.m\n    first_col = df.iloc[:, 0]\n    if not pd.api.types.is_datetime64_any_dtype(first_col):\n        raise ValueError(\n            \"First column must be of datetime type data for PROPHET_PREDICT!\"\n        )\n    df.rename(\n        columns={df.columns[0]: \"ds\", df.columns[1]: \"y\"}, inplace=True\n    )  # PROPHET model expects first column to be `ds` and second to be `y`\n    model = prophet.Prophet()\n    model.fit(df)\n    extra = {\"prophet\": model_to_json(model), \"run_forecast\": run_forecast}\n    # If run_forecast, the return df is the forecast, otherwise the original\n    return_df = df.copy()\n    if run_forecast:\n        future = model.make_future_dataframe(periods)\n        forecast = model.predict(future)\n        extra[\"original\"] = df\n        return_df = forecast\n\n    return DataFrame(df=return_df, extra=extra)\n"
}