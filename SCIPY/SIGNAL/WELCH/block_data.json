{
  "description": "The description of that function is as follows:\n\n        Estimate power spectral density using Welch's method.\n\n        Welch's method [1]_ computes an estimate of the power spectral density by dividing the data into overlapping segments,\n        computing a modified periodogram for each segment, and averaging the periodograms.",
  "parameters": [
    {
      "name": "select_return",
      "type": "'f', 'Pxx'",
      "description": "Select the desired object to return.\nSee the respective function docs for descriptors."
    },
    {
      "name": "x",
      "type": "array_like",
      "description": "Time series of measurement values."
    },
    {
      "name": "fs",
      "type": "float",
      "description": "Sampling frequency of the 'x' time series.\nDefaults to 1.0."
    },
    {
      "name": "window",
      "type": "str or tuple or array_like",
      "description": "Desired window to use. If 'window' is a string or tuple, it is\npassed to 'get_window' to generate the window values, which are\nDFT-even by default.\nSee 'get_window' for a list of windows and required parameters.\nIf 'window' is array_like,it will be used directly as the window\nand its length must be nperseg.\nDefaults to a Hann window."
    },
    {
      "name": "nperseg",
      "type": "int",
      "description": "Length of each segment.\nDefaults to None, but if window is str or tuple, is set to 256,\nand if window is array_like, is set to the length of the window."
    },
    {
      "name": "noverlap",
      "type": "int",
      "description": "Number of points to overlap between segments.\nIf 'None', noverlap = nperseg // 2.\nDefaults to 'None'."
    },
    {
      "name": "nfft",
      "type": "int",
      "description": "Length of the FFT used, if a zero padded FFT is desired.\nIf 'None', the FFT length is 'nperseg'.\nDefaults to 'None'."
    },
    {
      "name": "detrend",
      "type": "str or function or 'False'",
      "description": "Specifies how to detrend each segment.\nIf 'detrend' is a string, it is passed as the 'type' argument to the 'detrend' function.\nIf it is a function, it takes a segment and returns a detrended segment.\nIf 'detrend' is 'False', no detrending is done.\nDefaults to 'constant'."
    },
    {
      "name": "return_onesided",
      "type": "bool",
      "description": "If 'True', returns a one-sided spectrum for real data.\nIf 'False', returns a two-sided spectrum.\nDefaults to 'True', but for complex data, a two-sided spectrum is always returned."
    },
    {
      "name": "scaling",
      "type": "{ 'density', 'spectrum' }",
      "description": "Selects between computing the power spectral density ('density')\nwhere 'Pxx' has units of V**2/Hz and computing the power\nspectrum ('spectrum') where 'Pxx' has units of V**2, if 'x'\nis measured in V and 'fs' is measured in Hz.\nDefaults to 'density'."
    },
    {
      "name": "axis",
      "type": "int",
      "description": "Axis along which the periodogram is computed.\nThe default is over the last axis (i.e. axis=-1)."
    },
    {
      "name": "average",
      "type": "{ 'mean', 'median' }",
      "description": "Method to use when averaging periodograms.\nDefaults to 'mean'."
    },
    {
      "name": ".. versionadded",
      "type": ": 1.2.0",
      "description": null
    }
  ],
  "returns": [
    {
      "name": null,
      "type": "DataContainer",
      "description": "type 'ordered pair', 'scalar', or 'matrix'"
    }
  ],
  "code": "from flojoy import OrderedPair, flojoy, Matrix, Scalar\nimport numpy as np\nfrom collections import namedtuple\nfrom typing import Literal\n\nimport scipy.signal\n\n\n@flojoy\ndef WELCH(\n    default: OrderedPair | Matrix,\n    fs: float = 1.0,\n    window: str = \"hann\",\n    nperseg: int = 2,\n    noverlap: int = 1,\n    nfft: int = 2,\n    detrend: str = \"constant\",\n    return_onesided: bool = True,\n    scaling: str = \"density\",\n    axis: int = -1,\n    average: str = \"mean\",\n    select_return: Literal[\"f\", \"Pxx\"] = \"f\",\n) -> OrderedPair | Matrix | Scalar:\n    \"\"\"The WELCH node is based on a numpy or scipy function.\n\n    The description of that function is as follows:\n\n            Estimate power spectral density using Welch's method.\n\n            Welch's method [1]_ computes an estimate of the power spectral density by dividing the data into overlapping segments,\n            computing a modified periodogram for each segment, and averaging the periodograms.\n\n    Parameters\n    ----------\n    select_return : 'f', 'Pxx'\n        Select the desired object to return.\n        See the respective function docs for descriptors.\n    x : array_like\n        Time series of measurement values.\n    fs : float, optional\n        Sampling frequency of the 'x' time series.\n        Defaults to 1.0.\n    window : str or tuple or array_like, optional\n        Desired window to use. If 'window' is a string or tuple, it is\n        passed to 'get_window' to generate the window values, which are\n        DFT-even by default.\n        See 'get_window' for a list of windows and required parameters.\n        If 'window' is array_like,it will be used directly as the window\n        and its length must be nperseg.\n        Defaults to a Hann window.\n    nperseg : int, optional\n        Length of each segment.\n        Defaults to None, but if window is str or tuple, is set to 256,\n        and if window is array_like, is set to the length of the window.\n    noverlap : int, optional\n        Number of points to overlap between segments.\n        If 'None', noverlap = nperseg // 2.\n        Defaults to 'None'.\n    nfft : int, optional\n        Length of the FFT used, if a zero padded FFT is desired.\n        If 'None', the FFT length is 'nperseg'.\n        Defaults to 'None'.\n    detrend : str or function or 'False', optional\n        Specifies how to detrend each segment.\n        If 'detrend' is a string, it is passed as the 'type' argument to the 'detrend' function.\n        If it is a function, it takes a segment and returns a detrended segment.\n        If 'detrend' is 'False', no detrending is done.\n        Defaults to 'constant'.\n    return_onesided : bool, optional\n        If 'True', returns a one-sided spectrum for real data.\n        If 'False', returns a two-sided spectrum.\n        Defaults to 'True', but for complex data, a two-sided spectrum is always returned.\n    scaling : { 'density', 'spectrum' }, optional\n        Selects between computing the power spectral density ('density')\n        where 'Pxx' has units of V**2/Hz and computing the power\n        spectrum ('spectrum') where 'Pxx' has units of V**2, if 'x'\n        is measured in V and 'fs' is measured in Hz.\n        Defaults to 'density'.\n    axis : int, optional\n        Axis along which the periodogram is computed.\n        The default is over the last axis (i.e. axis=-1).\n    average : { 'mean', 'median' }, optional\n        Method to use when averaging periodograms.\n        Defaults to 'mean'.\n\n    .. versionadded:: 1.2.0\n\n    Returns\n    -------\n    DataContainer\n        type 'ordered pair', 'scalar', or 'matrix'\n    \"\"\"\n\n    result = scipy.signal.welch(\n        x=default.y,\n        fs=fs,\n        window=window,\n        nperseg=nperseg,\n        noverlap=noverlap,\n        nfft=nfft,\n        detrend=detrend,\n        return_onesided=return_onesided,\n        scaling=scaling,\n        axis=axis,\n        average=average,\n    )\n\n    return_list = [\"f\", \"Pxx\"]\n    if isinstance(result, tuple):\n        res_dict = {}\n        num = min(len(result), len(return_list))\n        for i in range(num):\n            res_dict[return_list[i]] = result[i]\n        result = res_dict[select_return]\n    else:\n        result = result._asdict()\n        result = result[select_return]\n\n    if isinstance(result, np.ndarray):\n        result = OrderedPair(x=default.x, y=result)\n    else:\n        assert isinstance(\n            result, np.number | float | int\n        ), f\"Expected np.number, float or int for result, got {type(result)}\"\n        result = Scalar(c=float(result))\n\n    return result\n"
}