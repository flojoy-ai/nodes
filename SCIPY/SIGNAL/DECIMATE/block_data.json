{
  "description": "The description of that function is as follows:\n\n    Downsample the signal after applying an anti-aliasing filter.\n\n    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR filter with Hamming window is used if `ftype` is 'fir'.",
  "parameters": [
    {
      "name": "x",
      "type": "array_like",
      "description": "The signal to be downsampled, as an N-dimensional array."
    },
    {
      "name": "q",
      "type": "int",
      "description": "The downsampling factor. When using IIR downsampling, it is recommended\nto call `decimate` multiple times for downsampling factors higher than 13."
    },
    {
      "name": "n",
      "type": "int",
      "description": "The order of the filter (1 less than the length for 'fir').\nDefaults to 8 for 'iir' and 20 times the downsampling factor for 'fir'."
    },
    {
      "name": "ftype",
      "type": "str {'iir', 'fir'} or \"dlti\" instance",
      "description": "If 'iir' or 'fir', specifies the type of lowpass filter.\nIf an instance of an \"dlti\" object, uses that object to filter before downsampling."
    },
    {
      "name": "axis",
      "type": "int",
      "description": "The axis along which to decimate."
    },
    {
      "name": "zero_phase",
      "type": "bool",
      "description": "Prevent phase shift by filtering with 'filtfilt' instead of 'lfilter'\nwhen using an IIR filter, and shifting the outputs back by the filter's\ngroup delay when using an FIR filter. The default value of 'True' is\nrecommended, since a phase shift is generally not desired."
    },
    {
      "name": ".. versionadded",
      "type": ": 0.18.0",
      "description": null
    }
  ],
  "returns": [
    {
      "name": null,
      "type": "DataContainer",
      "description": "type 'ordered pair', 'scalar', or 'matrix'"
    }
  ],
  "code": "from flojoy import OrderedPair, flojoy, Matrix, Scalar\nimport numpy as np\nfrom collections import namedtuple\nfrom typing import Literal\n\nimport scipy.signal\n\n\n@flojoy\ndef DECIMATE(\n    default: OrderedPair | Matrix,\n    q: int = 2,\n    n: int = 2,\n    ftype: str = \"iir\",\n    axis: int = -1,\n    zero_phase: bool = True,\n) -> OrderedPair | Matrix | Scalar:\n    \"\"\"The DECIMATE node is based on a numpy or scipy function.\n\n    The description of that function is as follows:\n\n        Downsample the signal after applying an anti-aliasing filter.\n\n        By default, an order 8 Chebyshev type I filter is used. A 30 point FIR filter with Hamming window is used if `ftype` is 'fir'.\n\n    Parameters\n    ----------\n    x : array_like\n        The signal to be downsampled, as an N-dimensional array.\n    q : int\n        The downsampling factor. When using IIR downsampling, it is recommended\n        to call `decimate` multiple times for downsampling factors higher than 13.\n    n : int, optional\n        The order of the filter (1 less than the length for 'fir').\n        Defaults to 8 for 'iir' and 20 times the downsampling factor for 'fir'.\n    ftype : str {'iir', 'fir'} or \"dlti\" instance, optional\n        If 'iir' or 'fir', specifies the type of lowpass filter.\n        If an instance of an \"dlti\" object, uses that object to filter before downsampling.\n    axis : int, optional\n        The axis along which to decimate.\n    zero_phase : bool, optional\n        Prevent phase shift by filtering with 'filtfilt' instead of 'lfilter'\n        when using an IIR filter, and shifting the outputs back by the filter's\n        group delay when using an FIR filter. The default value of 'True' is\n        recommended, since a phase shift is generally not desired.\n\n    .. versionadded:: 0.18.0\n\n    Returns\n    -------\n    DataContainer\n        type 'ordered pair', 'scalar', or 'matrix'\n    \"\"\"\n\n    result = scipy.signal.decimate(\n        x=default.y,\n        q=q,\n        n=n,\n        ftype=ftype,\n        axis=axis,\n        zero_phase=zero_phase,\n    )\n\n    if isinstance(result, np.ndarray):\n        result = OrderedPair(x=default.x, y=result)\n    else:\n        assert isinstance(\n            result, np.number | float | int\n        ), f\"Expected np.number, float or int for result, got {type(result)}\"\n        result = Scalar(c=float(result))\n\n    return result\n"
}