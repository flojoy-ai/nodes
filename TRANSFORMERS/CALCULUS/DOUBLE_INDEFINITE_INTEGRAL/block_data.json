{
  "description": "The width and height represent the number of columns and rows, respectively, that the x, y, and z reshaped matrices will have.\nHere it is important to note that the length of x, y, and z is the same, and that the width times the height needs to be equal to the length of x, y, and z.\n\nIt computes the double integral approximation according to given dimensions of the matrices, and returns a matrix where each cell represents the volume up to the given point.\n\nInputs\n------\ndefault : OrderedTriple\n    Input from which we use x, y, and z to compute the integral.",
  "parameters": [
    {
      "name": "width",
      "type": "int",
      "description": "Number of columns of the 3 matrices generated by reshaping the x, y, and z columns of the OrderedTriple."
    },
    {
      "name": "height",
      "type": "int",
      "description": "Number of rows of the 3 matrices generated by reshaping the x, y, and z columns of the OrderedTriple."
    }
  ],
  "returns": [
    {
      "name": null,
      "type": "Matrix",
      "description": "The matrix that contains the volume up to that point in each cell."
    }
  ],
  "code": "from flojoy import flojoy, OrderedTriple, Matrix\nimport numpy as np\n\n\ndef contains_only_numbers(column, colName):\n    for i in range(0, len(column)):\n        if not isinstance(column.item(i), (int, float)):\n            raise ValueError(\n                f\"The value {column.item(i)} in column {colName} is of type {type(column.item(i))}. The OrderedTriple need to contain only int or float values.\"\n            )\n\n\n@flojoy\ndef DOUBLE_INDEFINITE_INTEGRAL(\n    default: OrderedTriple, width: int = 3, height: int = 3\n) -> Matrix:\n    \"\"\"The DOUBLE_INDEFINITE_INTEGRAL node takes an OrderedTriple (x,y,z) and has width and height parameters.\n\n    The width and height represent the number of columns and rows, respectively, that the x, y, and z reshaped matrices will have.\n    Here it is important to note that the length of x, y, and z is the same, and that the width times the height needs to be equal to the length of x, y, and z.\n\n    It computes the double integral approximation according to given dimensions of the matrices, and returns a matrix where each cell represents the volume up to the given point.\n\n    Inputs\n    ------\n    default : OrderedTriple\n        Input from which we use x, y, and z to compute the integral.\n\n    Parameters\n    ----------\n    width : int\n        Number of columns of the 3 matrices generated by reshaping the x, y, and z columns of the OrderedTriple.\n    height : int\n        Number of rows of the 3 matrices generated by reshaping the x, y, and z columns of the OrderedTriple.\n\n    Returns\n    -------\n    Matrix\n        The matrix that contains the volume up to that point in each cell.\n    \"\"\"\n\n    if np.divide(len(default.x), width) == height:\n        contains_only_numbers(default.x, \"x\")\n        contains_only_numbers(default.y, \"y\")\n        contains_only_numbers(default.z, \"z\")\n\n        input_x = np.reshape(default.x, (height, width))\n        input_y = np.reshape(default.y, (height, width))\n        input_z = np.reshape(default.z, (height, width))\n    else:\n        raise ArithmeticError(\n            f\"Cannot reshape size {len(default.x)} in a matrix of {width} by {height}. Please enter appropriate width and height.\"\n        )\n\n    integrate = np.zeros_like(input_x)\n\n    for i in range(1, len(input_x)):\n        for j in range(1, width):\n            cal = (\n                (input_x[i][j] - input_x[i][j - 1])\n                * (input_y[i][j] - input_y[i - 1][j])\n                / 4\n            )\n            result = cal * (\n                input_z[i - 1][j - 1]\n                + input_z[i][j - 1]\n                + input_z[i - 1][j]\n                + input_z[i][j]\n            )\n            integrate[i][j] = result\n\n    result = np.copy(integrate)\n\n    for i in range(1, len(integrate)):\n        for j in range(1, width):\n            if i == 1:\n                result[i][j] = result[i][j - 1] + result[i][j]\n            elif j == 1:\n                result[i][j] = result[i - 1][j] + result[i][j]\n            else:\n                result[i][j] = (\n                    result[i][j - 1]\n                    + result[i - 1][j]\n                    + result[i][j]\n                    - result[i - 1][j - 1]\n                )\n\n    return Matrix(m=result)\n"
}