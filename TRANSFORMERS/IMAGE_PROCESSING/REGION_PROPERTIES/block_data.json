{
  "description": "There are multiple input 'DataContainer' types for which\nthis function is applicable: 'Image', 'Grayscale', or 'Matrix'.\n\nOften in image analysis, it is necessary to determine subvolumes / subregions\ninside a given image, whether for object count (e.g. the counting of\ncells on a glass plate), or object dimensional analysis (determining coutours of\na region, centroid of a region relative to the pixel coordinate origin of the image,\ndetermining the semi-major or -minor axes of a region, etc.). This functionality\nis entirely provided by this node in a two-step process:\n\n- First, the regions of the INTEGER image are identified and labelled.\n- Second, the regions are analyzed.\n\nThe first step is provided by the morphology library of scikit-image's label function,\nwhile the second is provided by scikit-image's regionprops function.\n\nAfter processing, the results of this node are visualized in the main UI,\nwhere the user can see:\n- The input array / image.\n- The semi-major and semi-minor axes of the contour drawn relative to the contour centroid.\n- The contour centroid.\n- The countour bounding-box.\n- A mouse-hover utility that displays the contour information to the user.",
  "parameters": [
    {
      "name": "default",
      "type": "Image | Grayscale",
      "description": "The input node to this function.\nIf nothing is supplied, a demo test case is returned to illustrate the functionality of this node."
    }
  ],
  "returns": [
    {
      "name": "fig",
      "type": "Plotly",
      "description": "A Plotly figure containing the illustrated features as determined by this node."
    }
  ],
  "code": "from flojoy import flojoy, Plotly, Image, Grayscale, Matrix\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom skimage.draw import ellipse\nfrom skimage.measure import label, regionprops, find_contours\nfrom skimage.transform import rotate\nimport re\nimport numpy as np\nfrom typing import Optional\nimport math\nfrom nodes.VISUALIZERS.template import plot_layout\nfrom PIL import Image as PILImage\n\n\n@flojoy(deps={\"scikit-image\": \"0.21.0\"}, node_type=\"VISUALIZERS\")\ndef REGION_PROPERTIES(default: Optional[Image | Grayscale | Matrix] = None) -> Plotly:\n    \"\"\"The image processing REGION_PROPERTIES node is a stand-alone visualizer for analyzing an input array of data.\n\n    There are multiple input 'DataContainer' types for which\n    this function is applicable: 'Image', 'Grayscale', or 'Matrix'.\n\n    Often in image analysis, it is necessary to determine subvolumes / subregions\n    inside a given image, whether for object count (e.g. the counting of\n    cells on a glass plate), or object dimensional analysis (determining coutours of\n    a region, centroid of a region relative to the pixel coordinate origin of the image,\n    determining the semi-major or -minor axes of a region, etc.). This functionality\n    is entirely provided by this node in a two-step process:\n\n    - First, the regions of the INTEGER image are identified and labelled.\n    - Second, the regions are analyzed.\n\n    The first step is provided by the morphology library of scikit-image's label function,\n    while the second is provided by scikit-image's regionprops function.\n\n    After processing, the results of this node are visualized in the main UI,\n    where the user can see:\n    - The input array / image.\n    - The semi-major and semi-minor axes of the contour drawn relative to the contour centroid.\n    - The contour centroid.\n    - The countour bounding-box.\n    - A mouse-hover utility that displays the contour information to the user.\n\n    Parameters\n    ----------\n    default : Image | Grayscale\n        The input node to this function.\n        If nothing is supplied, a demo test case is returned to illustrate the functionality of this node.\n\n    Returns\n    -------\n    fig: Plotly\n        A Plotly figure containing the illustrated features as determined by this node.\n    \"\"\"\n\n    if default:\n        if isinstance(default, Image):\n            r = default.r\n            g = default.g\n            b = default.b\n            a = default.a\n\n            if a is None:\n                image = np.stack((r, g, b), axis=2)\n            else:\n                image = np.stack((r, g, b, a), axis=2)\n            image = PILImage.fromarray(image)\n            image = np.array(\n                image.convert(\"L\"), dtype=np.uint8\n            )  # a greyscale image that can be processed\n        elif isinstance(default, Grayscale) or isinstance(default, Matrix):\n            image = np.array(default.m)  # explicit typing just to be extra safe\n\n    else:\n        image = np.zeros((600, 600), dtype=np.uint8)\n        rr, cc = ellipse(300, 350, 100, 220)\n        image[rr, cc] = 1\n        image = rotate(image, angle=15, order=0)\n        rr, cc = ellipse(100, 100, 60, 50)\n        image[rr, cc] = 1\n\n    # Slight problem. If we're generating a dummy dataset, or if the input is of\n    # type `Image`, then there is no problem for the below, since all values will\n    # be in range 0-255 (uint8). This is good because the array `rgb_image` below\n    # is guaranteed to be able to work and visualize the input array, and the `label`\n    # are `regionprops` routines, which only accept integer array inputs, will be fine\n    # as well. PROBLEM: if the input type is greyscale or matrix, meaning only a 2D\n    # array, we have at no point enforced that the values of these arrays be uint8.\n    # Indeed, they may not and in most cases will not be, and can have values within\n    # an extreme dynamic range. To fix this, we need a case to explicitly handle greyscale\n    # and matrix input data types, both for visualization and for region property analysis.\n    original_dtype = str(np.min_scalar_type(image))\n    if \"int\" in original_dtype:  # we are good, and all are integers\n        pass\n    elif \"f\" in original_dtype:  # matches 'float' and 'f8' etc\n        nbits = int(re.search(r\"\\d+\", str(original_dtype)).group())\n        image = image.astype(getattr(np, f\"int{nbits}\"))\n    else:\n        raise TypeError(\n            \"Input array of insufficient data type to pass to the region analysis routines.\"\n        )\n    labels = label(image)\n    rprops = regionprops(label_image=labels, intensity_image=image)\n\n    rgb_image = np.zeros(\n        (*image.shape, 3), dtype=np.uint8\n    )  # only generated for plotting\n    rgb_image[..., 0] = image * 255  # Red channel\n    rgb_image[..., 1] = image * 255  # Green channel\n    rgb_image[..., 2] = image * 255  # Blue channel\n    layout = plot_layout(title=f\"IMAGE with {labels.max()} objects\")\n    fig = px.imshow(img=rgb_image)\n    fig.layout = layout\n\n    properties = [\n        \"area\",\n        \"eccentricity\",\n        \"perimeter\",\n        \"centroid\",\n        \"orientation\",\n        \"axis_major_length\",\n        \"axis_minor_length\",\n    ]\n\n    for props in rprops:\n        y0, x0 = props.centroid\n        orientation = props.orientation\n        x1 = x0 + math.cos(orientation) * 0.5 * props.axis_minor_length\n        y1 = y0 - math.sin(orientation) * 0.5 * props.axis_minor_length\n        x2 = x0 - math.sin(orientation) * 0.5 * props.axis_major_length\n        y2 = y0 - math.cos(orientation) * 0.5 * props.axis_major_length\n\n        line_trace1 = go.Scatter(\n            x=[x0, x1],\n            y=[y0, y1],\n            mode=\"lines\",\n            line=dict(color=\"red\", width=2.5),\n            showlegend=False,\n        )\n        line_trace2 = go.Scatter(\n            x=[x0, x2],\n            y=[y0, y2],\n            mode=\"lines\",\n            line=dict(color=\"red\", width=2.5),\n            showlegend=False,\n        )\n        marker_trace = go.Scatter(\n            x=[x0],\n            y=[y0],\n            mode=\"markers\",\n            marker=dict(color=\"green\", size=15),\n            showlegend=False,\n        )\n\n        fig.add_trace(line_trace1)\n        fig.add_trace(line_trace2)\n        fig.add_trace(marker_trace)\n\n        minr, minc, maxr, maxc = props.bbox\n        bx = [minc, maxc, maxc, minc, minc]\n        by = [minr, minr, maxr, maxr, minr]\n\n        bounding_box_trace = go.Scatter(\n            x=bx, y=by, mode=\"lines\", line=dict(color=\"blue\", width=2), showlegend=False\n        )\n        fig.add_trace(bounding_box_trace)\n\n    for index in range(labels.max()):\n        label_i = rprops[index].label\n        contour = find_contours(labels == label_i, 0.5)[0]\n        y, x = contour.T\n        hoverinfo = \"\"\n        for prop_name in properties:\n            val = getattr(rprops[index], prop_name)\n            if type(val) == tuple:\n                line = [\n                    f\" <b>{prop_name}_{idv}: {v:.2f}</b>\" for idv, v in enumerate(val)\n                ]\n                hoverinfo += \",\".join(line) + \"<br>\"\n            else:\n                hoverinfo += f\"<b>{prop_name}: {val:.2f}</b><br>\"\n        fig.add_trace(\n            go.Scatter(\n                x=x,\n                y=y,\n                name=label_i,\n                mode=\"lines\",\n                fill=\"toself\",\n                showlegend=False,\n                hovertemplate=hoverinfo,\n                hoveron=\"points+fills\",\n            )\n        )\n\n    fig.update_xaxes(range=[0, image.shape[0]])\n    fig.update_yaxes(range=[0, image.shape[1]])\n    return Plotly(fig=fig)\n"
}