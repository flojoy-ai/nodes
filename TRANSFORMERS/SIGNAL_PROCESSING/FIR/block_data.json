{
  "description": "This filter takes a few inputs: the sample_rate (will be passed as a parameter if the target node is not connected), the window type of the filter, the cutoff frequency, and the number of taps (or length) of the filter.\n\nInputs\n------\ndefault : OrderedPair\n    The data to apply a FIR filter to.",
  "parameters": [
    {
      "name": "sample_rate",
      "type": "int",
      "description": "the amount of samples within a second"
    },
    {
      "name": "filter_type",
      "type": "select",
      "description": "how the filter behaves"
    },
    {
      "name": "window",
      "type": "select",
      "description": "the window function used in the FIR"
    },
    {
      "name": "cutoff_low",
      "type": "float",
      "description": "the frequency cutoff to filter out the lower frequencies"
    },
    {
      "name": "cutoff_high",
      "type": "float",
      "description": "the frequency cutoff to filter out the upper frequencies"
    },
    {
      "name": "taps",
      "type": "int",
      "description": "the length of the filter"
    }
  ],
  "returns": [
    {
      "name": null,
      "type": "OrderedPair",
      "description": "x: time domain\ny: filtered signal"
    }
  ],
  "code": "from scipy import signal\nfrom flojoy import flojoy, OrderedPair\nfrom typing import Literal, Union\n\n\n@flojoy\ndef FIR(\n    default: OrderedPair,\n    sample_rate: int = 100,\n    filter_type: Literal[\"lowpass\", \"highpass\", \"bandpass\", \"bandstop\"] = \"lowpass\",\n    window: Literal[\n        \"boxcar\",\n        \"triang\",\n        \"blackman\",\n        \"hamming\",\n        \"hann\",\n        \"bartlett\",\n        \"flattop\",\n        \"parzen\",\n        \"bohman\",\n        \"blackmanharris\",\n        \"nuttall\",\n        \"barthann\",\n        \"cosine\",\n        \"exponential\",\n        \"tukey\",\n        \"taylor\",\n        \"lanczos\",\n    ] = \"hann\",\n    cutoff_low: float = 10.0,\n    cutoff_high: float = 15.0,\n    taps: int = 200,\n) -> OrderedPair:\n    \"\"\"The FIR node applies a low-pass FIR filter to an input vector. The filter is designed with the window method.\n\n    This filter takes a few inputs: the sample_rate (will be passed as a parameter if the target node is not connected), the window type of the filter, the cutoff frequency, and the number of taps (or length) of the filter.\n\n    Inputs\n    ------\n    default : OrderedPair\n        The data to apply a FIR filter to.\n\n    Parameters\n    ----------\n    sample_rate : int\n        the amount of samples within a second\n    filter_type : select\n        how the filter behaves\n    window : select\n        the window function used in the FIR\n    cutoff_low : float\n        the frequency cutoff to filter out the lower frequencies\n    cutoff_high : float\n        the frequency cutoff to filter out the upper frequencies\n    taps : int\n        the length of the filter\n\n    Returns\n    -------\n    OrderedPair\n        x: time domain\n        y: filtered signal\n    \"\"\"\n\n    sample_rate: int = sample_rate  # Hz\n    filter_type: str = filter_type\n    window_type: str = window\n    cutoff_low: float = cutoff_low\n    cutoff_high: float = cutoff_high\n    n_taps: int = taps\n    times = default.x\n    input_signal = default.y\n\n    if input_signal.size < n_taps * 3:\n        raise ValueError(\"length of the data should be three times longer than taps\")\n    elif (\n        n_taps % 2 == 0\n    ):  # in the case where the passband contains the Nyquist frequency\n        n_taps = n_taps + 1\n\n    # create the filter with the parameter inputs\n    if filter_type == \"bandpass\" or filter_type == \"bandstop\":\n        fil = signal.firwin(\n            numtaps=n_taps,\n            cutoff=[cutoff_low, cutoff_high],\n            fs=sample_rate,\n            pass_zero=filter_type,\n            window=window_type,\n        )\n    elif filter_type == \"lowpass\":\n        fil = signal.firwin(\n            numtaps=n_taps,\n            cutoff=cutoff_high,\n            fs=sample_rate,\n            pass_zero=filter_type,\n            window=window_type,\n        )\n    else:\n        fil = signal.firwin(\n            numtaps=n_taps,\n            cutoff=cutoff_low,\n            fs=sample_rate,\n            pass_zero=filter_type,\n            window=window_type,\n        )\n\n    # ... and then apply it to the signal\n    filtered_x = signal.filtfilt(fil, 1.0, input_signal)\n    return OrderedPair(x=times, y=filtered_x)\n"
}