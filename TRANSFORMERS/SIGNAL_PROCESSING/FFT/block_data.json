{
  "description": "Through the FFT algorithm, the input vector will be transformed from a time domain into a frequency domain, which will be an ordered pair of arrays.\n\nInputs\n------\ndefault : OrderedPair\n    The data to apply FFT to.",
  "parameters": [
    {
      "name": "window",
      "type": "select",
      "description": "the node will apply a window to the signal to avoid spectral leakage"
    },
    {
      "name": "real_signal",
      "type": "boolean",
      "description": "whether the input signal is real or complex"
    },
    {
      "name": "sample_rate",
      "type": "int",
      "description": "the sample rate of the signal, defaults to 1"
    },
    {
      "name": "display",
      "type": "boolean",
      "description": "whether the output would be graphed, set to false for pure data and true for data that is more suitable to be graphed"
    }
  ],
  "returns": [
    {
      "name": null,
      "type": "OrderedPair if display is true",
      "description": "x: frequency\ny: spectrum of the signal"
    },
    {
      "name": null,
      "type": "DataFrame if display is false",
      "description": "time: time domain\nfrequency: frequency domain\nreal: real section of the signal\nimag: imaginary section of the signal"
    }
  ],
  "code": "from scipy import signal, fft\nfrom numpy import abs\nfrom flojoy import flojoy, OrderedPair, DataFrame\nfrom typing import Literal\nfrom pandas import DataFrame as df\n\n\n@flojoy\ndef FFT(\n    default: OrderedPair,\n    window: Literal[\n        \"none\",\n        \"boxcar\",\n        \"triang\",\n        \"blackman\",\n        \"hamming\",\n        \"hann\",\n        \"bartlett\",\n        \"flattop\",\n        \"parzen\",\n        \"bohman\",\n        \"blackmanharris\",\n        \"nuttall\",\n        \"barthann\",\n        \"cosine\",\n        \"exponential\",\n        \"tukey\",\n        \"taylor\",\n        \"lanczos\",\n    ] = \"hann\",\n    real_signal: bool = True,\n    sample_rate: int = 1,\n    display: bool = True,\n) -> OrderedPair | DataFrame:\n    \"\"\"The FFT node performs a Discrete Fourier Transform on the input vector.\n\n    Through the FFT algorithm, the input vector will be transformed from a time domain into a frequency domain, which will be an ordered pair of arrays.\n\n    Inputs\n    ------\n    default : OrderedPair\n        The data to apply FFT to.\n\n    Parameters\n    ----------\n    window : select\n        the node will apply a window to the signal to avoid spectral leakage\n    real_signal : boolean\n        whether the input signal is real or complex\n    sample_rate : int\n        the sample rate of the signal, defaults to 1\n    display : boolean\n        whether the output would be graphed, set to false for pure data and true for data that is more suitable to be graphed\n\n    Returns\n    -------\n    OrderedPair if display is true\n        x: frequency\n        y: spectrum of the signal\n    DataFrame if display is false\n        time: time domain\n        frequency: frequency domain\n        real: real section of the signal\n        imag: imaginary section of the signal\n    \"\"\"\n\n    if sample_rate <= 0:\n        raise ValueError(f\"Sample rate must be greater than 0\")\n\n    signal_value = default.y\n    x = default.x\n    sample_spacing = 1.0 / sample_rate\n    # x-axis\n    frequency = (\n        fft.rfftfreq(x.shape[-1], sample_spacing)\n        if real_signal and display\n        else fft.fftfreq(x.shape[-1], sample_spacing)\n    )\n    frequency = fft.fftshift(frequency)\n    if display:\n        # y-axis\n        if window == \"none\":\n            fourier = fft.rfft(signal_value) if real_signal else fft.fft(signal_value)\n        else:\n            window = signal.get_window(window, len(signal_value))\n            fourier = (\n                fft.rfft(signal_value * window)\n                if real_signal\n                else fft.fft(signal_value * window)\n            )\n        fourier = fft.fftshift(fourier)\n        fourier = abs(fourier)\n        return OrderedPair(x=frequency, y=fourier)\n\n    # for processing\n    fourier = fft.fft(signal_value)\n    d = {\"x\": x, \"frequency\": frequency, \"real\": fourier.real, \"imag\": fourier.imag}\n    return DataFrame(df=df(data=d))\n"
}