{
  "description": null,
  "parameters": [
    {
      "name": "num_readings",
      "type": "int",
      "description": "Number of points to record."
    },
    {
      "name": "record_period",
      "type": "float",
      "description": "Length between two recordings in seconds."
    },
    {
      "name": "baudrate",
      "type": "int",
      "description": "Baud rate for the serial device."
    },
    {
      "name": "comport",
      "type": "string",
      "description": "COM port of the serial device."
    },
    {
      "name": "num_readings * record_period",
      "type": "",
      "description": "Is roughly the run length in seconds."
    }
  ],
  "returns": [],
  "code": "from flojoy import flojoy, OrderedPair\nfrom time import sleep\nfrom typing import Optional\nimport serial\nimport numpy as np\nfrom datetime import datetime\n\n\n@flojoy(deps={\"pyserial\": \"3.5\"})\ndef SERIAL_TIMESERIES(\n    default: Optional[OrderedPair] = None,\n    comport: str = \"/dev/ttyUSB0\",\n    baudrate: int = 9600,\n    num_readings: int = 100,\n    record_period: int = 1,\n) -> OrderedPair:\n    \"\"\"The SERIAL_TIMESERIES node extracts simple time-dependent 1D data from an Arduino or a similar serial device.\n\n    Parameters\n    ----------\n    num_readings : int\n        Number of points to record.\n    record_period : float\n        Length between two recordings in seconds.\n    baudrate : int\n        Baud rate for the serial device.\n    comport : string\n        COM port of the serial device.\n\n    num_readings * record_period :\n        Is roughly the run length in seconds.\n    \"\"\"\n\n    ser = serial.Serial(comport, timeout=1, baudrate=baudrate)\n    readings = []\n    times = []\n    # The first reading is commonly empty.\n    s = ser.readline().decode()\n\n    for i in range(num_readings):\n        ts = datetime.now()\n        s = ser.readline().decode()\n        # Some readings may be empty.\n        if s != \"\":\n            reading = s[:-2].split(\",\")\n            if len(reading) == 1:\n                reading = reading[0]\n            readings.append(reading)\n\n            ts = datetime.now()\n            seconds = float(\n                ts.hour * 3600 + ts.minute * 60 + ts.second + ts.microsecond / 10**6\n            )\n\n            times.append(seconds)\n\n            if len(times) > 0:\n                time1 = seconds - times[i]\n            else:\n                # Estimate execution time.\n                time1 = 0.1\n\n            if time1 < record_period:\n                sleep(record_period - time1)\n\n    times = np.array(times)\n    try:\n        times -= times[0]\n    except IndexError:\n        raise IndexError(\"No data detected from the Arduino\")\n\n    readings = np.array(readings)\n    readings = readings.astype(\"float64\")\n\n    return OrderedPair(x=times, y=readings)\n"
}